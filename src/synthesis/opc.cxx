// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "opc.hxx"

// NamespaceTable
// 

const NamespaceTable::Namespace_sequence& NamespaceTable::
Namespace () const
{
  return this->Namespace_;
}

NamespaceTable::Namespace_sequence& NamespaceTable::
Namespace ()
{
  return this->Namespace_;
}

void NamespaceTable::
Namespace (const Namespace_sequence& s)
{
  this->Namespace_ = s;
}


// Namespace
// 

const Namespace::Name_optional& Namespace::
Name () const
{
  return this->Name_;
}

Namespace::Name_optional& Namespace::
Name ()
{
  return this->Name_;
}

void Namespace::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void Namespace::
Name (const Name_optional& x)
{
  this->Name_ = x;
}

void Namespace::
Name (::std::auto_ptr< Name_type > x)
{
  this->Name_.set (x);
}

const Namespace::Prefix_optional& Namespace::
Prefix () const
{
  return this->Prefix_;
}

Namespace::Prefix_optional& Namespace::
Prefix ()
{
  return this->Prefix_;
}

void Namespace::
Prefix (const Prefix_type& x)
{
  this->Prefix_.set (x);
}

void Namespace::
Prefix (const Prefix_optional& x)
{
  this->Prefix_ = x;
}

void Namespace::
Prefix (::std::auto_ptr< Prefix_type > x)
{
  this->Prefix_.set (x);
}

const Namespace::InternalPrefix_optional& Namespace::
InternalPrefix () const
{
  return this->InternalPrefix_;
}

Namespace::InternalPrefix_optional& Namespace::
InternalPrefix ()
{
  return this->InternalPrefix_;
}

void Namespace::
InternalPrefix (const InternalPrefix_type& x)
{
  this->InternalPrefix_.set (x);
}

void Namespace::
InternalPrefix (const InternalPrefix_optional& x)
{
  this->InternalPrefix_ = x;
}

void Namespace::
InternalPrefix (::std::auto_ptr< InternalPrefix_type > x)
{
  this->InternalPrefix_.set (x);
}

const Namespace::XmlNamespace_optional& Namespace::
XmlNamespace () const
{
  return this->XmlNamespace_;
}

Namespace::XmlNamespace_optional& Namespace::
XmlNamespace ()
{
  return this->XmlNamespace_;
}

void Namespace::
XmlNamespace (const XmlNamespace_type& x)
{
  this->XmlNamespace_.set (x);
}

void Namespace::
XmlNamespace (const XmlNamespace_optional& x)
{
  this->XmlNamespace_ = x;
}

void Namespace::
XmlNamespace (::std::auto_ptr< XmlNamespace_type > x)
{
  this->XmlNamespace_.set (x);
}

const Namespace::XmlPrefix_optional& Namespace::
XmlPrefix () const
{
  return this->XmlPrefix_;
}

Namespace::XmlPrefix_optional& Namespace::
XmlPrefix ()
{
  return this->XmlPrefix_;
}

void Namespace::
XmlPrefix (const XmlPrefix_type& x)
{
  this->XmlPrefix_.set (x);
}

void Namespace::
XmlPrefix (const XmlPrefix_optional& x)
{
  this->XmlPrefix_ = x;
}

void Namespace::
XmlPrefix (::std::auto_ptr< XmlPrefix_type > x)
{
  this->XmlPrefix_.set (x);
}

const Namespace::FilePath_optional& Namespace::
FilePath () const
{
  return this->FilePath_;
}

Namespace::FilePath_optional& Namespace::
FilePath ()
{
  return this->FilePath_;
}

void Namespace::
FilePath (const FilePath_type& x)
{
  this->FilePath_.set (x);
}

void Namespace::
FilePath (const FilePath_optional& x)
{
  this->FilePath_ = x;
}

void Namespace::
FilePath (::std::auto_ptr< FilePath_type > x)
{
  this->FilePath_.set (x);
}


// NodeDesign
// 

const NodeDesign::BrowseName_optional& NodeDesign::
BrowseName () const
{
  return this->BrowseName_;
}

NodeDesign::BrowseName_optional& NodeDesign::
BrowseName ()
{
  return this->BrowseName_;
}

void NodeDesign::
BrowseName (const BrowseName_type& x)
{
  this->BrowseName_.set (x);
}

void NodeDesign::
BrowseName (const BrowseName_optional& x)
{
  this->BrowseName_ = x;
}

void NodeDesign::
BrowseName (::std::auto_ptr< BrowseName_type > x)
{
  this->BrowseName_.set (x);
}

const NodeDesign::DisplayName_optional& NodeDesign::
DisplayName () const
{
  return this->DisplayName_;
}

NodeDesign::DisplayName_optional& NodeDesign::
DisplayName ()
{
  return this->DisplayName_;
}

void NodeDesign::
DisplayName (const DisplayName_type& x)
{
  this->DisplayName_.set (x);
}

void NodeDesign::
DisplayName (const DisplayName_optional& x)
{
  this->DisplayName_ = x;
}

void NodeDesign::
DisplayName (::std::auto_ptr< DisplayName_type > x)
{
  this->DisplayName_.set (x);
}

const NodeDesign::Description_optional& NodeDesign::
Description () const
{
  return this->Description_;
}

NodeDesign::Description_optional& NodeDesign::
Description ()
{
  return this->Description_;
}

void NodeDesign::
Description (const Description_type& x)
{
  this->Description_.set (x);
}

void NodeDesign::
Description (const Description_optional& x)
{
  this->Description_ = x;
}

void NodeDesign::
Description (::std::auto_ptr< Description_type > x)
{
  this->Description_.set (x);
}

const NodeDesign::Children_optional& NodeDesign::
Children () const
{
  return this->Children_;
}

NodeDesign::Children_optional& NodeDesign::
Children ()
{
  return this->Children_;
}

void NodeDesign::
Children (const Children_type& x)
{
  this->Children_.set (x);
}

void NodeDesign::
Children (const Children_optional& x)
{
  this->Children_ = x;
}

void NodeDesign::
Children (::std::auto_ptr< Children_type > x)
{
  this->Children_.set (x);
}

const NodeDesign::References_optional& NodeDesign::
References () const
{
  return this->References_;
}

NodeDesign::References_optional& NodeDesign::
References ()
{
  return this->References_;
}

void NodeDesign::
References (const References_type& x)
{
  this->References_.set (x);
}

void NodeDesign::
References (const References_optional& x)
{
  this->References_ = x;
}

void NodeDesign::
References (::std::auto_ptr< References_type > x)
{
  this->References_.set (x);
}

const NodeDesign::SymbolicName_optional& NodeDesign::
SymbolicName () const
{
  return this->SymbolicName_;
}

NodeDesign::SymbolicName_optional& NodeDesign::
SymbolicName ()
{
  return this->SymbolicName_;
}

void NodeDesign::
SymbolicName (const SymbolicName_type& x)
{
  this->SymbolicName_.set (x);
}

void NodeDesign::
SymbolicName (const SymbolicName_optional& x)
{
  this->SymbolicName_ = x;
}

void NodeDesign::
SymbolicName (::std::auto_ptr< SymbolicName_type > x)
{
  this->SymbolicName_.set (x);
}

const NodeDesign::SymbolicId_optional& NodeDesign::
SymbolicId () const
{
  return this->SymbolicId_;
}

NodeDesign::SymbolicId_optional& NodeDesign::
SymbolicId ()
{
  return this->SymbolicId_;
}

void NodeDesign::
SymbolicId (const SymbolicId_type& x)
{
  this->SymbolicId_.set (x);
}

void NodeDesign::
SymbolicId (const SymbolicId_optional& x)
{
  this->SymbolicId_ = x;
}

void NodeDesign::
SymbolicId (::std::auto_ptr< SymbolicId_type > x)
{
  this->SymbolicId_.set (x);
}

const NodeDesign::IsDeclaration_type& NodeDesign::
IsDeclaration () const
{
  return this->IsDeclaration_.get ();
}

NodeDesign::IsDeclaration_type& NodeDesign::
IsDeclaration ()
{
  return this->IsDeclaration_.get ();
}

void NodeDesign::
IsDeclaration (const IsDeclaration_type& x)
{
  this->IsDeclaration_.set (x);
}

NodeDesign::IsDeclaration_type NodeDesign::
IsDeclaration_default_value ()
{
  return IsDeclaration_type (false);
}

const NodeDesign::NumericId_optional& NodeDesign::
NumericId () const
{
  return this->NumericId_;
}

NodeDesign::NumericId_optional& NodeDesign::
NumericId ()
{
  return this->NumericId_;
}

void NodeDesign::
NumericId (const NumericId_type& x)
{
  this->NumericId_.set (x);
}

void NodeDesign::
NumericId (const NumericId_optional& x)
{
  this->NumericId_ = x;
}

const NodeDesign::StringId_optional& NodeDesign::
StringId () const
{
  return this->StringId_;
}

NodeDesign::StringId_optional& NodeDesign::
StringId ()
{
  return this->StringId_;
}

void NodeDesign::
StringId (const StringId_type& x)
{
  this->StringId_.set (x);
}

void NodeDesign::
StringId (const StringId_optional& x)
{
  this->StringId_ = x;
}

void NodeDesign::
StringId (::std::auto_ptr< StringId_type > x)
{
  this->StringId_.set (x);
}

const NodeDesign::WriteAccess_type& NodeDesign::
WriteAccess () const
{
  return this->WriteAccess_.get ();
}

NodeDesign::WriteAccess_type& NodeDesign::
WriteAccess ()
{
  return this->WriteAccess_.get ();
}

void NodeDesign::
WriteAccess (const WriteAccess_type& x)
{
  this->WriteAccess_.set (x);
}

NodeDesign::WriteAccess_type NodeDesign::
WriteAccess_default_value ()
{
  return WriteAccess_type (0U);
}

const NodeDesign::PartNo_type& NodeDesign::
PartNo () const
{
  return this->PartNo_.get ();
}

NodeDesign::PartNo_type& NodeDesign::
PartNo ()
{
  return this->PartNo_.get ();
}

void NodeDesign::
PartNo (const PartNo_type& x)
{
  this->PartNo_.set (x);
}

NodeDesign::PartNo_type NodeDesign::
PartNo_default_value ()
{
  return PartNo_type (0U);
}


// TypeDesign
// 

const TypeDesign::ClassName_optional& TypeDesign::
ClassName () const
{
  return this->ClassName_;
}

TypeDesign::ClassName_optional& TypeDesign::
ClassName ()
{
  return this->ClassName_;
}

void TypeDesign::
ClassName (const ClassName_type& x)
{
  this->ClassName_.set (x);
}

void TypeDesign::
ClassName (const ClassName_optional& x)
{
  this->ClassName_ = x;
}

void TypeDesign::
ClassName (::std::auto_ptr< ClassName_type > x)
{
  this->ClassName_.set (x);
}

const TypeDesign::BaseType_optional& TypeDesign::
BaseType () const
{
  return this->BaseType_;
}

TypeDesign::BaseType_optional& TypeDesign::
BaseType ()
{
  return this->BaseType_;
}

void TypeDesign::
BaseType (const BaseType_type& x)
{
  this->BaseType_.set (x);
}

void TypeDesign::
BaseType (const BaseType_optional& x)
{
  this->BaseType_ = x;
}

void TypeDesign::
BaseType (::std::auto_ptr< BaseType_type > x)
{
  this->BaseType_.set (x);
}

const TypeDesign::IsAbstract_type& TypeDesign::
IsAbstract () const
{
  return this->IsAbstract_.get ();
}

TypeDesign::IsAbstract_type& TypeDesign::
IsAbstract ()
{
  return this->IsAbstract_.get ();
}

void TypeDesign::
IsAbstract (const IsAbstract_type& x)
{
  this->IsAbstract_.set (x);
}

TypeDesign::IsAbstract_type TypeDesign::
IsAbstract_default_value ()
{
  return IsAbstract_type (false);
}

const TypeDesign::NoClassGeneration_type& TypeDesign::
NoClassGeneration () const
{
  return this->NoClassGeneration_.get ();
}

TypeDesign::NoClassGeneration_type& TypeDesign::
NoClassGeneration ()
{
  return this->NoClassGeneration_.get ();
}

void TypeDesign::
NoClassGeneration (const NoClassGeneration_type& x)
{
  this->NoClassGeneration_.set (x);
}

TypeDesign::NoClassGeneration_type TypeDesign::
NoClassGeneration_default_value ()
{
  return NoClassGeneration_type (false);
}


// ObjectTypeDesign
// 

const ObjectTypeDesign::SupportsEvents_optional& ObjectTypeDesign::
SupportsEvents () const
{
  return this->SupportsEvents_;
}

ObjectTypeDesign::SupportsEvents_optional& ObjectTypeDesign::
SupportsEvents ()
{
  return this->SupportsEvents_;
}

void ObjectTypeDesign::
SupportsEvents (const SupportsEvents_type& x)
{
  this->SupportsEvents_.set (x);
}

void ObjectTypeDesign::
SupportsEvents (const SupportsEvents_optional& x)
{
  this->SupportsEvents_ = x;
}


// VariableTypeDesign
// 

const VariableTypeDesign::DefaultValue_optional& VariableTypeDesign::
DefaultValue () const
{
  return this->DefaultValue_;
}

VariableTypeDesign::DefaultValue_optional& VariableTypeDesign::
DefaultValue ()
{
  return this->DefaultValue_;
}

void VariableTypeDesign::
DefaultValue (const DefaultValue_type& x)
{
  this->DefaultValue_.set (x);
}

void VariableTypeDesign::
DefaultValue (const DefaultValue_optional& x)
{
  this->DefaultValue_ = x;
}

void VariableTypeDesign::
DefaultValue (::std::auto_ptr< DefaultValue_type > x)
{
  this->DefaultValue_.set (x);
}

const VariableTypeDesign::DataType_optional& VariableTypeDesign::
DataType () const
{
  return this->DataType_;
}

VariableTypeDesign::DataType_optional& VariableTypeDesign::
DataType ()
{
  return this->DataType_;
}

void VariableTypeDesign::
DataType (const DataType_type& x)
{
  this->DataType_.set (x);
}

void VariableTypeDesign::
DataType (const DataType_optional& x)
{
  this->DataType_ = x;
}

void VariableTypeDesign::
DataType (::std::auto_ptr< DataType_type > x)
{
  this->DataType_.set (x);
}

const VariableTypeDesign::ValueRank_optional& VariableTypeDesign::
ValueRank () const
{
  return this->ValueRank_;
}

VariableTypeDesign::ValueRank_optional& VariableTypeDesign::
ValueRank ()
{
  return this->ValueRank_;
}

void VariableTypeDesign::
ValueRank (const ValueRank_type& x)
{
  this->ValueRank_.set (x);
}

void VariableTypeDesign::
ValueRank (const ValueRank_optional& x)
{
  this->ValueRank_ = x;
}

void VariableTypeDesign::
ValueRank (::std::auto_ptr< ValueRank_type > x)
{
  this->ValueRank_.set (x);
}

const VariableTypeDesign::ArrayDimensions_optional& VariableTypeDesign::
ArrayDimensions () const
{
  return this->ArrayDimensions_;
}

VariableTypeDesign::ArrayDimensions_optional& VariableTypeDesign::
ArrayDimensions ()
{
  return this->ArrayDimensions_;
}

void VariableTypeDesign::
ArrayDimensions (const ArrayDimensions_type& x)
{
  this->ArrayDimensions_.set (x);
}

void VariableTypeDesign::
ArrayDimensions (const ArrayDimensions_optional& x)
{
  this->ArrayDimensions_ = x;
}

void VariableTypeDesign::
ArrayDimensions (::std::auto_ptr< ArrayDimensions_type > x)
{
  this->ArrayDimensions_.set (x);
}

const VariableTypeDesign::AccessLevel_optional& VariableTypeDesign::
AccessLevel () const
{
  return this->AccessLevel_;
}

VariableTypeDesign::AccessLevel_optional& VariableTypeDesign::
AccessLevel ()
{
  return this->AccessLevel_;
}

void VariableTypeDesign::
AccessLevel (const AccessLevel_type& x)
{
  this->AccessLevel_.set (x);
}

void VariableTypeDesign::
AccessLevel (const AccessLevel_optional& x)
{
  this->AccessLevel_ = x;
}

void VariableTypeDesign::
AccessLevel (::std::auto_ptr< AccessLevel_type > x)
{
  this->AccessLevel_.set (x);
}

const VariableTypeDesign::MinimumSamplingInterval_optional& VariableTypeDesign::
MinimumSamplingInterval () const
{
  return this->MinimumSamplingInterval_;
}

VariableTypeDesign::MinimumSamplingInterval_optional& VariableTypeDesign::
MinimumSamplingInterval ()
{
  return this->MinimumSamplingInterval_;
}

void VariableTypeDesign::
MinimumSamplingInterval (const MinimumSamplingInterval_type& x)
{
  this->MinimumSamplingInterval_.set (x);
}

void VariableTypeDesign::
MinimumSamplingInterval (const MinimumSamplingInterval_optional& x)
{
  this->MinimumSamplingInterval_ = x;
}

const VariableTypeDesign::Historizing_optional& VariableTypeDesign::
Historizing () const
{
  return this->Historizing_;
}

VariableTypeDesign::Historizing_optional& VariableTypeDesign::
Historizing ()
{
  return this->Historizing_;
}

void VariableTypeDesign::
Historizing (const Historizing_type& x)
{
  this->Historizing_.set (x);
}

void VariableTypeDesign::
Historizing (const Historizing_optional& x)
{
  this->Historizing_ = x;
}

const VariableTypeDesign::ExposesItsChildren_type& VariableTypeDesign::
ExposesItsChildren () const
{
  return this->ExposesItsChildren_.get ();
}

VariableTypeDesign::ExposesItsChildren_type& VariableTypeDesign::
ExposesItsChildren ()
{
  return this->ExposesItsChildren_.get ();
}

void VariableTypeDesign::
ExposesItsChildren (const ExposesItsChildren_type& x)
{
  this->ExposesItsChildren_.set (x);
}

VariableTypeDesign::ExposesItsChildren_type VariableTypeDesign::
ExposesItsChildren_default_value ()
{
  return ExposesItsChildren_type (false);
}


// DataTypeDesign
// 

const DataTypeDesign::Fields_optional& DataTypeDesign::
Fields () const
{
  return this->Fields_;
}

DataTypeDesign::Fields_optional& DataTypeDesign::
Fields ()
{
  return this->Fields_;
}

void DataTypeDesign::
Fields (const Fields_type& x)
{
  this->Fields_.set (x);
}

void DataTypeDesign::
Fields (const Fields_optional& x)
{
  this->Fields_ = x;
}

void DataTypeDesign::
Fields (::std::auto_ptr< Fields_type > x)
{
  this->Fields_.set (x);
}

const DataTypeDesign::Encodings_optional& DataTypeDesign::
Encodings () const
{
  return this->Encodings_;
}

DataTypeDesign::Encodings_optional& DataTypeDesign::
Encodings ()
{
  return this->Encodings_;
}

void DataTypeDesign::
Encodings (const Encodings_type& x)
{
  this->Encodings_.set (x);
}

void DataTypeDesign::
Encodings (const Encodings_optional& x)
{
  this->Encodings_ = x;
}

void DataTypeDesign::
Encodings (::std::auto_ptr< Encodings_type > x)
{
  this->Encodings_.set (x);
}

const DataTypeDesign::NoArraysAllowed_type& DataTypeDesign::
NoArraysAllowed () const
{
  return this->NoArraysAllowed_.get ();
}

DataTypeDesign::NoArraysAllowed_type& DataTypeDesign::
NoArraysAllowed ()
{
  return this->NoArraysAllowed_.get ();
}

void DataTypeDesign::
NoArraysAllowed (const NoArraysAllowed_type& x)
{
  this->NoArraysAllowed_.set (x);
}

DataTypeDesign::NoArraysAllowed_type DataTypeDesign::
NoArraysAllowed_default_value ()
{
  return NoArraysAllowed_type (false);
}

const DataTypeDesign::NotInAddressSpace_type& DataTypeDesign::
NotInAddressSpace () const
{
  return this->NotInAddressSpace_.get ();
}

DataTypeDesign::NotInAddressSpace_type& DataTypeDesign::
NotInAddressSpace ()
{
  return this->NotInAddressSpace_.get ();
}

void DataTypeDesign::
NotInAddressSpace (const NotInAddressSpace_type& x)
{
  this->NotInAddressSpace_.set (x);
}

DataTypeDesign::NotInAddressSpace_type DataTypeDesign::
NotInAddressSpace_default_value ()
{
  return NotInAddressSpace_type (false);
}


// ReferenceTypeDesign
// 

const ReferenceTypeDesign::InverseName_optional& ReferenceTypeDesign::
InverseName () const
{
  return this->InverseName_;
}

ReferenceTypeDesign::InverseName_optional& ReferenceTypeDesign::
InverseName ()
{
  return this->InverseName_;
}

void ReferenceTypeDesign::
InverseName (const InverseName_type& x)
{
  this->InverseName_.set (x);
}

void ReferenceTypeDesign::
InverseName (const InverseName_optional& x)
{
  this->InverseName_ = x;
}

void ReferenceTypeDesign::
InverseName (::std::auto_ptr< InverseName_type > x)
{
  this->InverseName_.set (x);
}

const ReferenceTypeDesign::Symmetric_optional& ReferenceTypeDesign::
Symmetric () const
{
  return this->Symmetric_;
}

ReferenceTypeDesign::Symmetric_optional& ReferenceTypeDesign::
Symmetric ()
{
  return this->Symmetric_;
}

void ReferenceTypeDesign::
Symmetric (const Symmetric_type& x)
{
  this->Symmetric_.set (x);
}

void ReferenceTypeDesign::
Symmetric (const Symmetric_optional& x)
{
  this->Symmetric_ = x;
}


// InstanceDesign
// 

const InstanceDesign::ReferenceType_optional& InstanceDesign::
ReferenceType () const
{
  return this->ReferenceType_;
}

InstanceDesign::ReferenceType_optional& InstanceDesign::
ReferenceType ()
{
  return this->ReferenceType_;
}

void InstanceDesign::
ReferenceType (const ReferenceType_type& x)
{
  this->ReferenceType_.set (x);
}

void InstanceDesign::
ReferenceType (const ReferenceType_optional& x)
{
  this->ReferenceType_ = x;
}

void InstanceDesign::
ReferenceType (::std::auto_ptr< ReferenceType_type > x)
{
  this->ReferenceType_.set (x);
}

const InstanceDesign::Declaration_optional& InstanceDesign::
Declaration () const
{
  return this->Declaration_;
}

InstanceDesign::Declaration_optional& InstanceDesign::
Declaration ()
{
  return this->Declaration_;
}

void InstanceDesign::
Declaration (const Declaration_type& x)
{
  this->Declaration_.set (x);
}

void InstanceDesign::
Declaration (const Declaration_optional& x)
{
  this->Declaration_ = x;
}

void InstanceDesign::
Declaration (::std::auto_ptr< Declaration_type > x)
{
  this->Declaration_.set (x);
}

const InstanceDesign::TypeDefinition_optional& InstanceDesign::
TypeDefinition () const
{
  return this->TypeDefinition_;
}

InstanceDesign::TypeDefinition_optional& InstanceDesign::
TypeDefinition ()
{
  return this->TypeDefinition_;
}

void InstanceDesign::
TypeDefinition (const TypeDefinition_type& x)
{
  this->TypeDefinition_.set (x);
}

void InstanceDesign::
TypeDefinition (const TypeDefinition_optional& x)
{
  this->TypeDefinition_ = x;
}

void InstanceDesign::
TypeDefinition (::std::auto_ptr< TypeDefinition_type > x)
{
  this->TypeDefinition_.set (x);
}

const InstanceDesign::ModellingRule_optional& InstanceDesign::
ModellingRule () const
{
  return this->ModellingRule_;
}

InstanceDesign::ModellingRule_optional& InstanceDesign::
ModellingRule ()
{
  return this->ModellingRule_;
}

void InstanceDesign::
ModellingRule (const ModellingRule_type& x)
{
  this->ModellingRule_.set (x);
}

void InstanceDesign::
ModellingRule (const ModellingRule_optional& x)
{
  this->ModellingRule_ = x;
}

void InstanceDesign::
ModellingRule (::std::auto_ptr< ModellingRule_type > x)
{
  this->ModellingRule_.set (x);
}

const InstanceDesign::MinCardinality_type& InstanceDesign::
MinCardinality () const
{
  return this->MinCardinality_.get ();
}

InstanceDesign::MinCardinality_type& InstanceDesign::
MinCardinality ()
{
  return this->MinCardinality_.get ();
}

void InstanceDesign::
MinCardinality (const MinCardinality_type& x)
{
  this->MinCardinality_.set (x);
}

InstanceDesign::MinCardinality_type InstanceDesign::
MinCardinality_default_value ()
{
  return MinCardinality_type (0U);
}

const InstanceDesign::MaxCardinality_type& InstanceDesign::
MaxCardinality () const
{
  return this->MaxCardinality_.get ();
}

InstanceDesign::MaxCardinality_type& InstanceDesign::
MaxCardinality ()
{
  return this->MaxCardinality_.get ();
}

void InstanceDesign::
MaxCardinality (const MaxCardinality_type& x)
{
  this->MaxCardinality_.set (x);
}

InstanceDesign::MaxCardinality_type InstanceDesign::
MaxCardinality_default_value ()
{
  return MaxCardinality_type (0U);
}

const InstanceDesign::PreserveDefaultAttributes_type& InstanceDesign::
PreserveDefaultAttributes () const
{
  return this->PreserveDefaultAttributes_.get ();
}

InstanceDesign::PreserveDefaultAttributes_type& InstanceDesign::
PreserveDefaultAttributes ()
{
  return this->PreserveDefaultAttributes_.get ();
}

void InstanceDesign::
PreserveDefaultAttributes (const PreserveDefaultAttributes_type& x)
{
  this->PreserveDefaultAttributes_.set (x);
}

InstanceDesign::PreserveDefaultAttributes_type InstanceDesign::
PreserveDefaultAttributes_default_value ()
{
  return PreserveDefaultAttributes_type (false);
}


// ViewDesign
// 

const ViewDesign::SupportsEvents_type& ViewDesign::
SupportsEvents () const
{
  return this->SupportsEvents_.get ();
}

ViewDesign::SupportsEvents_type& ViewDesign::
SupportsEvents ()
{
  return this->SupportsEvents_.get ();
}

void ViewDesign::
SupportsEvents (const SupportsEvents_type& x)
{
  this->SupportsEvents_.set (x);
}

ViewDesign::SupportsEvents_type ViewDesign::
SupportsEvents_default_value ()
{
  return SupportsEvents_type (false);
}

const ViewDesign::ContainsNoLoops_type& ViewDesign::
ContainsNoLoops () const
{
  return this->ContainsNoLoops_.get ();
}

ViewDesign::ContainsNoLoops_type& ViewDesign::
ContainsNoLoops ()
{
  return this->ContainsNoLoops_.get ();
}

void ViewDesign::
ContainsNoLoops (const ContainsNoLoops_type& x)
{
  this->ContainsNoLoops_.set (x);
}

ViewDesign::ContainsNoLoops_type ViewDesign::
ContainsNoLoops_default_value ()
{
  return ContainsNoLoops_type (false);
}


// ObjectDesign
// 

const ObjectDesign::SupportsEvents_optional& ObjectDesign::
SupportsEvents () const
{
  return this->SupportsEvents_;
}

ObjectDesign::SupportsEvents_optional& ObjectDesign::
SupportsEvents ()
{
  return this->SupportsEvents_;
}

void ObjectDesign::
SupportsEvents (const SupportsEvents_type& x)
{
  this->SupportsEvents_.set (x);
}

void ObjectDesign::
SupportsEvents (const SupportsEvents_optional& x)
{
  this->SupportsEvents_ = x;
}


// VariableDesign
// 

const VariableDesign::DefaultValue_optional& VariableDesign::
DefaultValue () const
{
  return this->DefaultValue_;
}

VariableDesign::DefaultValue_optional& VariableDesign::
DefaultValue ()
{
  return this->DefaultValue_;
}

void VariableDesign::
DefaultValue (const DefaultValue_type& x)
{
  this->DefaultValue_.set (x);
}

void VariableDesign::
DefaultValue (const DefaultValue_optional& x)
{
  this->DefaultValue_ = x;
}

void VariableDesign::
DefaultValue (::std::auto_ptr< DefaultValue_type > x)
{
  this->DefaultValue_.set (x);
}

const VariableDesign::DataType_optional& VariableDesign::
DataType () const
{
  return this->DataType_;
}

VariableDesign::DataType_optional& VariableDesign::
DataType ()
{
  return this->DataType_;
}

void VariableDesign::
DataType (const DataType_type& x)
{
  this->DataType_.set (x);
}

void VariableDesign::
DataType (const DataType_optional& x)
{
  this->DataType_ = x;
}

void VariableDesign::
DataType (::std::auto_ptr< DataType_type > x)
{
  this->DataType_.set (x);
}

const VariableDesign::ValueRank_optional& VariableDesign::
ValueRank () const
{
  return this->ValueRank_;
}

VariableDesign::ValueRank_optional& VariableDesign::
ValueRank ()
{
  return this->ValueRank_;
}

void VariableDesign::
ValueRank (const ValueRank_type& x)
{
  this->ValueRank_.set (x);
}

void VariableDesign::
ValueRank (const ValueRank_optional& x)
{
  this->ValueRank_ = x;
}

void VariableDesign::
ValueRank (::std::auto_ptr< ValueRank_type > x)
{
  this->ValueRank_.set (x);
}

const VariableDesign::ArrayDimensions_optional& VariableDesign::
ArrayDimensions () const
{
  return this->ArrayDimensions_;
}

VariableDesign::ArrayDimensions_optional& VariableDesign::
ArrayDimensions ()
{
  return this->ArrayDimensions_;
}

void VariableDesign::
ArrayDimensions (const ArrayDimensions_type& x)
{
  this->ArrayDimensions_.set (x);
}

void VariableDesign::
ArrayDimensions (const ArrayDimensions_optional& x)
{
  this->ArrayDimensions_ = x;
}

void VariableDesign::
ArrayDimensions (::std::auto_ptr< ArrayDimensions_type > x)
{
  this->ArrayDimensions_.set (x);
}

const VariableDesign::AccessLevel_optional& VariableDesign::
AccessLevel () const
{
  return this->AccessLevel_;
}

VariableDesign::AccessLevel_optional& VariableDesign::
AccessLevel ()
{
  return this->AccessLevel_;
}

void VariableDesign::
AccessLevel (const AccessLevel_type& x)
{
  this->AccessLevel_.set (x);
}

void VariableDesign::
AccessLevel (const AccessLevel_optional& x)
{
  this->AccessLevel_ = x;
}

void VariableDesign::
AccessLevel (::std::auto_ptr< AccessLevel_type > x)
{
  this->AccessLevel_.set (x);
}

const VariableDesign::MinimumSamplingInterval_optional& VariableDesign::
MinimumSamplingInterval () const
{
  return this->MinimumSamplingInterval_;
}

VariableDesign::MinimumSamplingInterval_optional& VariableDesign::
MinimumSamplingInterval ()
{
  return this->MinimumSamplingInterval_;
}

void VariableDesign::
MinimumSamplingInterval (const MinimumSamplingInterval_type& x)
{
  this->MinimumSamplingInterval_.set (x);
}

void VariableDesign::
MinimumSamplingInterval (const MinimumSamplingInterval_optional& x)
{
  this->MinimumSamplingInterval_ = x;
}

const VariableDesign::Historizing_optional& VariableDesign::
Historizing () const
{
  return this->Historizing_;
}

VariableDesign::Historizing_optional& VariableDesign::
Historizing ()
{
  return this->Historizing_;
}

void VariableDesign::
Historizing (const Historizing_type& x)
{
  this->Historizing_.set (x);
}

void VariableDesign::
Historizing (const Historizing_optional& x)
{
  this->Historizing_ = x;
}


// MethodDesign
// 

const MethodDesign::InputArguments_optional& MethodDesign::
InputArguments () const
{
  return this->InputArguments_;
}

MethodDesign::InputArguments_optional& MethodDesign::
InputArguments ()
{
  return this->InputArguments_;
}

void MethodDesign::
InputArguments (const InputArguments_type& x)
{
  this->InputArguments_.set (x);
}

void MethodDesign::
InputArguments (const InputArguments_optional& x)
{
  this->InputArguments_ = x;
}

void MethodDesign::
InputArguments (::std::auto_ptr< InputArguments_type > x)
{
  this->InputArguments_.set (x);
}

const MethodDesign::OutputArguments_optional& MethodDesign::
OutputArguments () const
{
  return this->OutputArguments_;
}

MethodDesign::OutputArguments_optional& MethodDesign::
OutputArguments ()
{
  return this->OutputArguments_;
}

void MethodDesign::
OutputArguments (const OutputArguments_type& x)
{
  this->OutputArguments_.set (x);
}

void MethodDesign::
OutputArguments (const OutputArguments_optional& x)
{
  this->OutputArguments_ = x;
}

void MethodDesign::
OutputArguments (::std::auto_ptr< OutputArguments_type > x)
{
  this->OutputArguments_.set (x);
}

const MethodDesign::NonExecutable_optional& MethodDesign::
NonExecutable () const
{
  return this->NonExecutable_;
}

MethodDesign::NonExecutable_optional& MethodDesign::
NonExecutable ()
{
  return this->NonExecutable_;
}

void MethodDesign::
NonExecutable (const NonExecutable_type& x)
{
  this->NonExecutable_.set (x);
}

void MethodDesign::
NonExecutable (const NonExecutable_optional& x)
{
  this->NonExecutable_ = x;
}


// PropertyDesign
// 


// EncodingDesign
// 


// DictionaryDesign
// 

const DictionaryDesign::EncodingName_type& DictionaryDesign::
EncodingName () const
{
  return this->EncodingName_.get ();
}

DictionaryDesign::EncodingName_type& DictionaryDesign::
EncodingName ()
{
  return this->EncodingName_.get ();
}

void DictionaryDesign::
EncodingName (const EncodingName_type& x)
{
  this->EncodingName_.set (x);
}

void DictionaryDesign::
EncodingName (::std::auto_ptr< EncodingName_type > x)
{
  this->EncodingName_.set (x);
}


// Reference
// 

const Reference::ReferenceType_type& Reference::
ReferenceType () const
{
  return this->ReferenceType_.get ();
}

Reference::ReferenceType_type& Reference::
ReferenceType ()
{
  return this->ReferenceType_.get ();
}

void Reference::
ReferenceType (const ReferenceType_type& x)
{
  this->ReferenceType_.set (x);
}

void Reference::
ReferenceType (::std::auto_ptr< ReferenceType_type > x)
{
  this->ReferenceType_.set (x);
}

const Reference::TargetId_type& Reference::
TargetId () const
{
  return this->TargetId_.get ();
}

Reference::TargetId_type& Reference::
TargetId ()
{
  return this->TargetId_.get ();
}

void Reference::
TargetId (const TargetId_type& x)
{
  this->TargetId_.set (x);
}

void Reference::
TargetId (::std::auto_ptr< TargetId_type > x)
{
  this->TargetId_.set (x);
}

const Reference::IsInverse_type& Reference::
IsInverse () const
{
  return this->IsInverse_.get ();
}

Reference::IsInverse_type& Reference::
IsInverse ()
{
  return this->IsInverse_.get ();
}

void Reference::
IsInverse (const IsInverse_type& x)
{
  this->IsInverse_.set (x);
}

Reference::IsInverse_type Reference::
IsInverse_default_value ()
{
  return IsInverse_type (false);
}

const Reference::IsOneWay_type& Reference::
IsOneWay () const
{
  return this->IsOneWay_.get ();
}

Reference::IsOneWay_type& Reference::
IsOneWay ()
{
  return this->IsOneWay_.get ();
}

void Reference::
IsOneWay (const IsOneWay_type& x)
{
  this->IsOneWay_.set (x);
}

Reference::IsOneWay_type Reference::
IsOneWay_default_value ()
{
  return IsOneWay_type (false);
}


// ListOfReferences
// 

const ListOfReferences::Reference_sequence& ListOfReferences::
Reference () const
{
  return this->Reference_;
}

ListOfReferences::Reference_sequence& ListOfReferences::
Reference ()
{
  return this->Reference_;
}

void ListOfReferences::
Reference (const Reference_sequence& s)
{
  this->Reference_ = s;
}


// Parameter
// 

const Parameter::Description_optional& Parameter::
Description () const
{
  return this->Description_;
}

Parameter::Description_optional& Parameter::
Description ()
{
  return this->Description_;
}

void Parameter::
Description (const Description_type& x)
{
  this->Description_.set (x);
}

void Parameter::
Description (const Description_optional& x)
{
  this->Description_ = x;
}

void Parameter::
Description (::std::auto_ptr< Description_type > x)
{
  this->Description_.set (x);
}

const Parameter::Name_optional& Parameter::
Name () const
{
  return this->Name_;
}

Parameter::Name_optional& Parameter::
Name ()
{
  return this->Name_;
}

void Parameter::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void Parameter::
Name (const Name_optional& x)
{
  this->Name_ = x;
}

void Parameter::
Name (::std::auto_ptr< Name_type > x)
{
  this->Name_.set (x);
}

const Parameter::Identifier_optional& Parameter::
Identifier () const
{
  return this->Identifier_;
}

Parameter::Identifier_optional& Parameter::
Identifier ()
{
  return this->Identifier_;
}

void Parameter::
Identifier (const Identifier_type& x)
{
  this->Identifier_.set (x);
}

void Parameter::
Identifier (const Identifier_optional& x)
{
  this->Identifier_ = x;
}

const Parameter::DataType_optional& Parameter::
DataType () const
{
  return this->DataType_;
}

Parameter::DataType_optional& Parameter::
DataType ()
{
  return this->DataType_;
}

void Parameter::
DataType (const DataType_type& x)
{
  this->DataType_.set (x);
}

void Parameter::
DataType (const DataType_optional& x)
{
  this->DataType_ = x;
}

void Parameter::
DataType (::std::auto_ptr< DataType_type > x)
{
  this->DataType_.set (x);
}

const Parameter::ValueRank_type& Parameter::
ValueRank () const
{
  return this->ValueRank_.get ();
}

Parameter::ValueRank_type& Parameter::
ValueRank ()
{
  return this->ValueRank_.get ();
}

void Parameter::
ValueRank (const ValueRank_type& x)
{
  this->ValueRank_.set (x);
}

void Parameter::
ValueRank (::std::auto_ptr< ValueRank_type > x)
{
  this->ValueRank_.set (x);
}

const Parameter::ValueRank_type& Parameter::
ValueRank_default_value ()
{
  return ValueRank_default_value_;
}

const Parameter::ArrayDimensions_optional& Parameter::
ArrayDimensions () const
{
  return this->ArrayDimensions_;
}

Parameter::ArrayDimensions_optional& Parameter::
ArrayDimensions ()
{
  return this->ArrayDimensions_;
}

void Parameter::
ArrayDimensions (const ArrayDimensions_type& x)
{
  this->ArrayDimensions_.set (x);
}

void Parameter::
ArrayDimensions (const ArrayDimensions_optional& x)
{
  this->ArrayDimensions_ = x;
}

void Parameter::
ArrayDimensions (::std::auto_ptr< ArrayDimensions_type > x)
{
  this->ArrayDimensions_.set (x);
}


// ListOfArguments
// 

const ListOfArguments::Argument_sequence& ListOfArguments::
Argument () const
{
  return this->Argument_;
}

ListOfArguments::Argument_sequence& ListOfArguments::
Argument ()
{
  return this->Argument_;
}

void ListOfArguments::
Argument (const Argument_sequence& s)
{
  this->Argument_ = s;
}


// ListOfFields
// 

const ListOfFields::Field_sequence& ListOfFields::
Field () const
{
  return this->Field_;
}

ListOfFields::Field_sequence& ListOfFields::
Field ()
{
  return this->Field_;
}

void ListOfFields::
Field (const Field_sequence& s)
{
  this->Field_ = s;
}


// ListOfEncodings
// 

const ListOfEncodings::Encoding_sequence& ListOfEncodings::
Encoding () const
{
  return this->Encoding_;
}

ListOfEncodings::Encoding_sequence& ListOfEncodings::
Encoding ()
{
  return this->Encoding_;
}

void ListOfEncodings::
Encoding (const Encoding_sequence& s)
{
  this->Encoding_ = s;
}


// ListOfChildren
// 

const ListOfChildren::Object_sequence& ListOfChildren::
Object () const
{
  return this->Object_;
}

ListOfChildren::Object_sequence& ListOfChildren::
Object ()
{
  return this->Object_;
}

void ListOfChildren::
Object (const Object_sequence& s)
{
  this->Object_ = s;
}

const ListOfChildren::Variable_sequence& ListOfChildren::
Variable () const
{
  return this->Variable_;
}

ListOfChildren::Variable_sequence& ListOfChildren::
Variable ()
{
  return this->Variable_;
}

void ListOfChildren::
Variable (const Variable_sequence& s)
{
  this->Variable_ = s;
}

const ListOfChildren::Property_sequence& ListOfChildren::
Property () const
{
  return this->Property_;
}

ListOfChildren::Property_sequence& ListOfChildren::
Property ()
{
  return this->Property_;
}

void ListOfChildren::
Property (const Property_sequence& s)
{
  this->Property_ = s;
}

const ListOfChildren::Method_sequence& ListOfChildren::
Method () const
{
  return this->Method_;
}

ListOfChildren::Method_sequence& ListOfChildren::
Method ()
{
  return this->Method_;
}

void ListOfChildren::
Method (const Method_sequence& s)
{
  this->Method_ = s;
}


// LocalizedText
// 

const LocalizedText::Key_type& LocalizedText::
Key () const
{
  return this->Key_.get ();
}

LocalizedText::Key_type& LocalizedText::
Key ()
{
  return this->Key_.get ();
}

void LocalizedText::
Key (const Key_type& x)
{
  this->Key_.set (x);
}

void LocalizedText::
Key (::std::auto_ptr< Key_type > x)
{
  this->Key_.set (x);
}

const LocalizedText::Key_type& LocalizedText::
Key_default_value ()
{
  return Key_default_value_;
}


// DefaultValue
// 


// AccessLevel
// 

AccessLevel::
AccessLevel (value v)
: ::xml_schema::string (_xsd_AccessLevel_literals_[v])
{
}

AccessLevel::
AccessLevel (const char* v)
: ::xml_schema::string (v)
{
}

AccessLevel::
AccessLevel (const ::std::string& v)
: ::xml_schema::string (v)
{
}

AccessLevel::
AccessLevel (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

AccessLevel::
AccessLevel (const AccessLevel& v,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

AccessLevel& AccessLevel::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_AccessLevel_literals_[v]);

  return *this;
}


// ValueRank
// 

ValueRank::
ValueRank (value v)
: ::xml_schema::string (_xsd_ValueRank_literals_[v])
{
}

ValueRank::
ValueRank (const char* v)
: ::xml_schema::string (v)
{
}

ValueRank::
ValueRank (const ::std::string& v)
: ::xml_schema::string (v)
{
}

ValueRank::
ValueRank (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

ValueRank::
ValueRank (const ValueRank& v,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

ValueRank& ValueRank::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_ValueRank_literals_[v]);

  return *this;
}


// ModellingRule
// 

ModellingRule::
ModellingRule (value v)
: ::xml_schema::string (_xsd_ModellingRule_literals_[v])
{
}

ModellingRule::
ModellingRule (const char* v)
: ::xml_schema::string (v)
{
}

ModellingRule::
ModellingRule (const ::std::string& v)
: ::xml_schema::string (v)
{
}

ModellingRule::
ModellingRule (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

ModellingRule::
ModellingRule (const ModellingRule& v,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

ModellingRule& ModellingRule::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_ModellingRule_literals_[v]);

  return *this;
}


// ModelDesign
// 

const ModelDesign::Namespaces_optional& ModelDesign::
Namespaces () const
{
  return this->Namespaces_;
}

ModelDesign::Namespaces_optional& ModelDesign::
Namespaces ()
{
  return this->Namespaces_;
}

void ModelDesign::
Namespaces (const Namespaces_type& x)
{
  this->Namespaces_.set (x);
}

void ModelDesign::
Namespaces (const Namespaces_optional& x)
{
  this->Namespaces_ = x;
}

void ModelDesign::
Namespaces (::std::auto_ptr< Namespaces_type > x)
{
  this->Namespaces_.set (x);
}

const ModelDesign::VariableType_sequence& ModelDesign::
VariableType () const
{
  return this->VariableType_;
}

ModelDesign::VariableType_sequence& ModelDesign::
VariableType ()
{
  return this->VariableType_;
}

void ModelDesign::
VariableType (const VariableType_sequence& s)
{
  this->VariableType_ = s;
}

const ModelDesign::ReferenceType_sequence& ModelDesign::
ReferenceType () const
{
  return this->ReferenceType_;
}

ModelDesign::ReferenceType_sequence& ModelDesign::
ReferenceType ()
{
  return this->ReferenceType_;
}

void ModelDesign::
ReferenceType (const ReferenceType_sequence& s)
{
  this->ReferenceType_ = s;
}

const ModelDesign::DataType_sequence& ModelDesign::
DataType () const
{
  return this->DataType_;
}

ModelDesign::DataType_sequence& ModelDesign::
DataType ()
{
  return this->DataType_;
}

void ModelDesign::
DataType (const DataType_sequence& s)
{
  this->DataType_ = s;
}

const ModelDesign::Method_sequence& ModelDesign::
Method () const
{
  return this->Method_;
}

ModelDesign::Method_sequence& ModelDesign::
Method ()
{
  return this->Method_;
}

void ModelDesign::
Method (const Method_sequence& s)
{
  this->Method_ = s;
}

const ModelDesign::ObjectType_sequence& ModelDesign::
ObjectType () const
{
  return this->ObjectType_;
}

ModelDesign::ObjectType_sequence& ModelDesign::
ObjectType ()
{
  return this->ObjectType_;
}

void ModelDesign::
ObjectType (const ObjectType_sequence& s)
{
  this->ObjectType_ = s;
}

const ModelDesign::Object_sequence& ModelDesign::
Object () const
{
  return this->Object_;
}

ModelDesign::Object_sequence& ModelDesign::
Object ()
{
  return this->Object_;
}

void ModelDesign::
Object (const Object_sequence& s)
{
  this->Object_ = s;
}

const ModelDesign::Variable_sequence& ModelDesign::
Variable () const
{
  return this->Variable_;
}

ModelDesign::Variable_sequence& ModelDesign::
Variable ()
{
  return this->Variable_;
}

void ModelDesign::
Variable (const Variable_sequence& s)
{
  this->Variable_ = s;
}

const ModelDesign::Property_sequence& ModelDesign::
Property () const
{
  return this->Property_;
}

ModelDesign::Property_sequence& ModelDesign::
Property ()
{
  return this->Property_;
}

void ModelDesign::
Property (const Property_sequence& s)
{
  this->Property_ = s;
}

const ModelDesign::Dictionary_sequence& ModelDesign::
Dictionary () const
{
  return this->Dictionary_;
}

ModelDesign::Dictionary_sequence& ModelDesign::
Dictionary ()
{
  return this->Dictionary_;
}

void ModelDesign::
Dictionary (const Dictionary_sequence& s)
{
  this->Dictionary_ = s;
}

const ModelDesign::View_sequence& ModelDesign::
View () const
{
  return this->View_;
}

ModelDesign::View_sequence& ModelDesign::
View ()
{
  return this->View_;
}

void ModelDesign::
View (const View_sequence& s)
{
  this->View_ = s;
}

const ModelDesign::TargetNamespace_type& ModelDesign::
TargetNamespace () const
{
  return this->TargetNamespace_.get ();
}

ModelDesign::TargetNamespace_type& ModelDesign::
TargetNamespace ()
{
  return this->TargetNamespace_.get ();
}

void ModelDesign::
TargetNamespace (const TargetNamespace_type& x)
{
  this->TargetNamespace_.set (x);
}

void ModelDesign::
TargetNamespace (::std::auto_ptr< TargetNamespace_type > x)
{
  this->TargetNamespace_.set (x);
}

const ModelDesign::TargetVersion_optional& ModelDesign::
TargetVersion () const
{
  return this->TargetVersion_;
}

ModelDesign::TargetVersion_optional& ModelDesign::
TargetVersion ()
{
  return this->TargetVersion_;
}

void ModelDesign::
TargetVersion (const TargetVersion_type& x)
{
  this->TargetVersion_.set (x);
}

void ModelDesign::
TargetVersion (const TargetVersion_optional& x)
{
  this->TargetVersion_ = x;
}

void ModelDesign::
TargetVersion (::std::auto_ptr< TargetVersion_type > x)
{
  this->TargetVersion_.set (x);
}

const ModelDesign::TargetPublicationDate_optional& ModelDesign::
TargetPublicationDate () const
{
  return this->TargetPublicationDate_;
}

ModelDesign::TargetPublicationDate_optional& ModelDesign::
TargetPublicationDate ()
{
  return this->TargetPublicationDate_;
}

void ModelDesign::
TargetPublicationDate (const TargetPublicationDate_type& x)
{
  this->TargetPublicationDate_.set (x);
}

void ModelDesign::
TargetPublicationDate (const TargetPublicationDate_optional& x)
{
  this->TargetPublicationDate_ = x;
}

void ModelDesign::
TargetPublicationDate (::std::auto_ptr< TargetPublicationDate_type > x)
{
  this->TargetPublicationDate_.set (x);
}

const ModelDesign::TargetXmlNamespace_optional& ModelDesign::
TargetXmlNamespace () const
{
  return this->TargetXmlNamespace_;
}

ModelDesign::TargetXmlNamespace_optional& ModelDesign::
TargetXmlNamespace ()
{
  return this->TargetXmlNamespace_;
}

void ModelDesign::
TargetXmlNamespace (const TargetXmlNamespace_type& x)
{
  this->TargetXmlNamespace_.set (x);
}

void ModelDesign::
TargetXmlNamespace (const TargetXmlNamespace_optional& x)
{
  this->TargetXmlNamespace_ = x;
}

void ModelDesign::
TargetXmlNamespace (::std::auto_ptr< TargetXmlNamespace_type > x)
{
  this->TargetXmlNamespace_.set (x);
}

const ModelDesign::DefaultLocale_type& ModelDesign::
DefaultLocale () const
{
  return this->DefaultLocale_.get ();
}

ModelDesign::DefaultLocale_type& ModelDesign::
DefaultLocale ()
{
  return this->DefaultLocale_.get ();
}

void ModelDesign::
DefaultLocale (const DefaultLocale_type& x)
{
  this->DefaultLocale_.set (x);
}

void ModelDesign::
DefaultLocale (::std::auto_ptr< DefaultLocale_type > x)
{
  this->DefaultLocale_.set (x);
}

const ModelDesign::DefaultLocale_type& ModelDesign::
DefaultLocale_default_value ()
{
  return DefaultLocale_default_value_;
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// NamespaceTable
//

NamespaceTable::
NamespaceTable ()
: ::xml_schema::type (),
  Namespace_ (this)
{
}

NamespaceTable::
NamespaceTable (const NamespaceTable& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Namespace_ (x.Namespace_, f, this)
{
}

NamespaceTable::
NamespaceTable (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Namespace_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void NamespaceTable::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Namespace
    //
    if (n.name () == "Namespace" && n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
    {
      ::std::auto_ptr< Namespace_type > r (
        Namespace_traits::create (i, f, this));

      this->Namespace_.push_back (r);
      continue;
    }

    break;
  }
}

NamespaceTable* NamespaceTable::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class NamespaceTable (*this, f, c);
}

NamespaceTable& NamespaceTable::
operator= (const NamespaceTable& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Namespace_ = x.Namespace_;
  }

  return *this;
}

NamespaceTable::
~NamespaceTable ()
{
}

// Namespace
//

Namespace::
Namespace ()
: ::xml_schema::string (),
  Name_ (this),
  Prefix_ (this),
  InternalPrefix_ (this),
  XmlNamespace_ (this),
  XmlPrefix_ (this),
  FilePath_ (this)
{
}

Namespace::
Namespace (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  Name_ (this),
  Prefix_ (this),
  InternalPrefix_ (this),
  XmlNamespace_ (this),
  XmlPrefix_ (this),
  FilePath_ (this)
{
}

Namespace::
Namespace (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  Name_ (this),
  Prefix_ (this),
  InternalPrefix_ (this),
  XmlNamespace_ (this),
  XmlPrefix_ (this),
  FilePath_ (this)
{
}

Namespace::
Namespace (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  Name_ (this),
  Prefix_ (this),
  InternalPrefix_ (this),
  XmlNamespace_ (this),
  XmlPrefix_ (this),
  FilePath_ (this)
{
}

Namespace::
Namespace (const Namespace& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  Name_ (x.Name_, f, this),
  Prefix_ (x.Prefix_, f, this),
  InternalPrefix_ (x.InternalPrefix_, f, this),
  XmlNamespace_ (x.XmlNamespace_, f, this),
  XmlPrefix_ (x.XmlPrefix_, f, this),
  FilePath_ (x.FilePath_, f, this)
{
}

Namespace::
Namespace (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  Name_ (this),
  Prefix_ (this),
  InternalPrefix_ (this),
  XmlNamespace_ (this),
  XmlPrefix_ (this),
  FilePath_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void Namespace::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      this->Name_.set (Name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Prefix" && n.namespace_ ().empty ())
    {
      this->Prefix_.set (Prefix_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "InternalPrefix" && n.namespace_ ().empty ())
    {
      this->InternalPrefix_.set (InternalPrefix_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "XmlNamespace" && n.namespace_ ().empty ())
    {
      this->XmlNamespace_.set (XmlNamespace_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "XmlPrefix" && n.namespace_ ().empty ())
    {
      this->XmlPrefix_.set (XmlPrefix_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "FilePath" && n.namespace_ ().empty ())
    {
      this->FilePath_.set (FilePath_traits::create (i, f, this));
      continue;
    }
  }
}

Namespace* Namespace::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Namespace (*this, f, c);
}

Namespace& Namespace::
operator= (const Namespace& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->Name_ = x.Name_;
    this->Prefix_ = x.Prefix_;
    this->InternalPrefix_ = x.InternalPrefix_;
    this->XmlNamespace_ = x.XmlNamespace_;
    this->XmlPrefix_ = x.XmlPrefix_;
    this->FilePath_ = x.FilePath_;
  }

  return *this;
}

Namespace::
~Namespace ()
{
}

// NodeDesign
//

NodeDesign::
NodeDesign ()
: ::xml_schema::type (),
  BrowseName_ (this),
  DisplayName_ (this),
  Description_ (this),
  Children_ (this),
  References_ (this),
  SymbolicName_ (this),
  SymbolicId_ (this),
  IsDeclaration_ (IsDeclaration_default_value (), this),
  NumericId_ (this),
  StringId_ (this),
  WriteAccess_ (WriteAccess_default_value (), this),
  PartNo_ (PartNo_default_value (), this)
{
}

NodeDesign::
NodeDesign (const NodeDesign& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  BrowseName_ (x.BrowseName_, f, this),
  DisplayName_ (x.DisplayName_, f, this),
  Description_ (x.Description_, f, this),
  Children_ (x.Children_, f, this),
  References_ (x.References_, f, this),
  SymbolicName_ (x.SymbolicName_, f, this),
  SymbolicId_ (x.SymbolicId_, f, this),
  IsDeclaration_ (x.IsDeclaration_, f, this),
  NumericId_ (x.NumericId_, f, this),
  StringId_ (x.StringId_, f, this),
  WriteAccess_ (x.WriteAccess_, f, this),
  PartNo_ (x.PartNo_, f, this)
{
}

NodeDesign::
NodeDesign (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  BrowseName_ (this),
  DisplayName_ (this),
  Description_ (this),
  Children_ (this),
  References_ (this),
  SymbolicName_ (this),
  SymbolicId_ (this),
  IsDeclaration_ (this),
  NumericId_ (this),
  StringId_ (this),
  WriteAccess_ (this),
  PartNo_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void NodeDesign::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // BrowseName
    //
    if (n.name () == "BrowseName" && n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
    {
      ::std::auto_ptr< BrowseName_type > r (
        BrowseName_traits::create (i, f, this));

      if (!this->BrowseName_)
      {
        this->BrowseName_.set (r);
        continue;
      }
    }

    // DisplayName
    //
    if (n.name () == "DisplayName" && n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
    {
      ::std::auto_ptr< DisplayName_type > r (
        DisplayName_traits::create (i, f, this));

      if (!this->DisplayName_)
      {
        this->DisplayName_.set (r);
        continue;
      }
    }

    // Description
    //
    if (n.name () == "Description" && n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
    {
      ::std::auto_ptr< Description_type > r (
        Description_traits::create (i, f, this));

      if (!this->Description_)
      {
        this->Description_.set (r);
        continue;
      }
    }

    // Children
    //
    if (n.name () == "Children" && n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
    {
      ::std::auto_ptr< Children_type > r (
        Children_traits::create (i, f, this));

      if (!this->Children_)
      {
        this->Children_.set (r);
        continue;
      }
    }

    // References
    //
    if (n.name () == "References" && n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
    {
      ::std::auto_ptr< References_type > r (
        References_traits::create (i, f, this));

      if (!this->References_)
      {
        this->References_.set (r);
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "SymbolicName" && n.namespace_ ().empty ())
    {
      this->SymbolicName_.set (SymbolicName_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "SymbolicId" && n.namespace_ ().empty ())
    {
      this->SymbolicId_.set (SymbolicId_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IsDeclaration" && n.namespace_ ().empty ())
    {
      this->IsDeclaration_.set (IsDeclaration_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "NumericId" && n.namespace_ ().empty ())
    {
      this->NumericId_.set (NumericId_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "StringId" && n.namespace_ ().empty ())
    {
      this->StringId_.set (StringId_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "WriteAccess" && n.namespace_ ().empty ())
    {
      this->WriteAccess_.set (WriteAccess_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "PartNo" && n.namespace_ ().empty ())
    {
      this->PartNo_.set (PartNo_traits::create (i, f, this));
      continue;
    }
  }

  if (!IsDeclaration_.present ())
  {
    this->IsDeclaration_.set (IsDeclaration_default_value ());
  }

  if (!WriteAccess_.present ())
  {
    this->WriteAccess_.set (WriteAccess_default_value ());
  }

  if (!PartNo_.present ())
  {
    this->PartNo_.set (PartNo_default_value ());
  }
}

NodeDesign* NodeDesign::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class NodeDesign (*this, f, c);
}

NodeDesign& NodeDesign::
operator= (const NodeDesign& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->BrowseName_ = x.BrowseName_;
    this->DisplayName_ = x.DisplayName_;
    this->Description_ = x.Description_;
    this->Children_ = x.Children_;
    this->References_ = x.References_;
    this->SymbolicName_ = x.SymbolicName_;
    this->SymbolicId_ = x.SymbolicId_;
    this->IsDeclaration_ = x.IsDeclaration_;
    this->NumericId_ = x.NumericId_;
    this->StringId_ = x.StringId_;
    this->WriteAccess_ = x.WriteAccess_;
    this->PartNo_ = x.PartNo_;
  }

  return *this;
}

NodeDesign::
~NodeDesign ()
{
}

// TypeDesign
//

TypeDesign::
TypeDesign ()
: ::NodeDesign (),
  ClassName_ (this),
  BaseType_ (this),
  IsAbstract_ (IsAbstract_default_value (), this),
  NoClassGeneration_ (NoClassGeneration_default_value (), this)
{
}

TypeDesign::
TypeDesign (const TypeDesign& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::NodeDesign (x, f, c),
  ClassName_ (x.ClassName_, f, this),
  BaseType_ (x.BaseType_, f, this),
  IsAbstract_ (x.IsAbstract_, f, this),
  NoClassGeneration_ (x.NoClassGeneration_, f, this)
{
}

TypeDesign::
TypeDesign (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::NodeDesign (e, f | ::xml_schema::flags::base, c),
  ClassName_ (this),
  BaseType_ (this),
  IsAbstract_ (this),
  NoClassGeneration_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void TypeDesign::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::NodeDesign::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ClassName
    //
    if (n.name () == "ClassName" && n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
    {
      ::std::auto_ptr< ClassName_type > r (
        ClassName_traits::create (i, f, this));

      if (!this->ClassName_)
      {
        this->ClassName_.set (r);
        continue;
      }
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "BaseType" && n.namespace_ ().empty ())
    {
      this->BaseType_.set (BaseType_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IsAbstract" && n.namespace_ ().empty ())
    {
      this->IsAbstract_.set (IsAbstract_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "NoClassGeneration" && n.namespace_ ().empty ())
    {
      this->NoClassGeneration_.set (NoClassGeneration_traits::create (i, f, this));
      continue;
    }
  }

  if (!IsAbstract_.present ())
  {
    this->IsAbstract_.set (IsAbstract_default_value ());
  }

  if (!NoClassGeneration_.present ())
  {
    this->NoClassGeneration_.set (NoClassGeneration_default_value ());
  }
}

TypeDesign* TypeDesign::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class TypeDesign (*this, f, c);
}

TypeDesign& TypeDesign::
operator= (const TypeDesign& x)
{
  if (this != &x)
  {
    static_cast< ::NodeDesign& > (*this) = x;
    this->ClassName_ = x.ClassName_;
    this->BaseType_ = x.BaseType_;
    this->IsAbstract_ = x.IsAbstract_;
    this->NoClassGeneration_ = x.NoClassGeneration_;
  }

  return *this;
}

TypeDesign::
~TypeDesign ()
{
}

// ObjectTypeDesign
//

ObjectTypeDesign::
ObjectTypeDesign ()
: ::TypeDesign (),
  SupportsEvents_ (this)
{
}

ObjectTypeDesign::
ObjectTypeDesign (const ObjectTypeDesign& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::TypeDesign (x, f, c),
  SupportsEvents_ (x.SupportsEvents_, f, this)
{
}

ObjectTypeDesign::
ObjectTypeDesign (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::TypeDesign (e, f | ::xml_schema::flags::base, c),
  SupportsEvents_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void ObjectTypeDesign::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::TypeDesign::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "SupportsEvents" && n.namespace_ ().empty ())
    {
      this->SupportsEvents_.set (SupportsEvents_traits::create (i, f, this));
      continue;
    }
  }
}

ObjectTypeDesign* ObjectTypeDesign::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ObjectTypeDesign (*this, f, c);
}

ObjectTypeDesign& ObjectTypeDesign::
operator= (const ObjectTypeDesign& x)
{
  if (this != &x)
  {
    static_cast< ::TypeDesign& > (*this) = x;
    this->SupportsEvents_ = x.SupportsEvents_;
  }

  return *this;
}

ObjectTypeDesign::
~ObjectTypeDesign ()
{
}

// VariableTypeDesign
//

VariableTypeDesign::
VariableTypeDesign ()
: ::TypeDesign (),
  DefaultValue_ (this),
  DataType_ (this),
  ValueRank_ (this),
  ArrayDimensions_ (this),
  AccessLevel_ (this),
  MinimumSamplingInterval_ (this),
  Historizing_ (this),
  ExposesItsChildren_ (ExposesItsChildren_default_value (), this)
{
}

VariableTypeDesign::
VariableTypeDesign (const VariableTypeDesign& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::TypeDesign (x, f, c),
  DefaultValue_ (x.DefaultValue_, f, this),
  DataType_ (x.DataType_, f, this),
  ValueRank_ (x.ValueRank_, f, this),
  ArrayDimensions_ (x.ArrayDimensions_, f, this),
  AccessLevel_ (x.AccessLevel_, f, this),
  MinimumSamplingInterval_ (x.MinimumSamplingInterval_, f, this),
  Historizing_ (x.Historizing_, f, this),
  ExposesItsChildren_ (x.ExposesItsChildren_, f, this)
{
}

VariableTypeDesign::
VariableTypeDesign (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::TypeDesign (e, f | ::xml_schema::flags::base, c),
  DefaultValue_ (this),
  DataType_ (this),
  ValueRank_ (this),
  ArrayDimensions_ (this),
  AccessLevel_ (this),
  MinimumSamplingInterval_ (this),
  Historizing_ (this),
  ExposesItsChildren_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void VariableTypeDesign::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::TypeDesign::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // DefaultValue
    //
    if (n.name () == "DefaultValue" && n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
    {
      ::std::auto_ptr< DefaultValue_type > r (
        DefaultValue_traits::create (i, f, this));

      if (!this->DefaultValue_)
      {
        this->DefaultValue_.set (r);
        continue;
      }
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "DataType" && n.namespace_ ().empty ())
    {
      this->DataType_.set (DataType_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "ValueRank" && n.namespace_ ().empty ())
    {
      this->ValueRank_.set (ValueRank_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "ArrayDimensions" && n.namespace_ ().empty ())
    {
      this->ArrayDimensions_.set (ArrayDimensions_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "AccessLevel" && n.namespace_ ().empty ())
    {
      this->AccessLevel_.set (AccessLevel_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "MinimumSamplingInterval" && n.namespace_ ().empty ())
    {
      this->MinimumSamplingInterval_.set (MinimumSamplingInterval_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Historizing" && n.namespace_ ().empty ())
    {
      this->Historizing_.set (Historizing_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "ExposesItsChildren" && n.namespace_ ().empty ())
    {
      this->ExposesItsChildren_.set (ExposesItsChildren_traits::create (i, f, this));
      continue;
    }
  }

  if (!ExposesItsChildren_.present ())
  {
    this->ExposesItsChildren_.set (ExposesItsChildren_default_value ());
  }
}

VariableTypeDesign* VariableTypeDesign::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class VariableTypeDesign (*this, f, c);
}

VariableTypeDesign& VariableTypeDesign::
operator= (const VariableTypeDesign& x)
{
  if (this != &x)
  {
    static_cast< ::TypeDesign& > (*this) = x;
    this->DefaultValue_ = x.DefaultValue_;
    this->DataType_ = x.DataType_;
    this->ValueRank_ = x.ValueRank_;
    this->ArrayDimensions_ = x.ArrayDimensions_;
    this->AccessLevel_ = x.AccessLevel_;
    this->MinimumSamplingInterval_ = x.MinimumSamplingInterval_;
    this->Historizing_ = x.Historizing_;
    this->ExposesItsChildren_ = x.ExposesItsChildren_;
  }

  return *this;
}

VariableTypeDesign::
~VariableTypeDesign ()
{
}

// DataTypeDesign
//

DataTypeDesign::
DataTypeDesign ()
: ::TypeDesign (),
  Fields_ (this),
  Encodings_ (this),
  NoArraysAllowed_ (NoArraysAllowed_default_value (), this),
  NotInAddressSpace_ (NotInAddressSpace_default_value (), this)
{
}

DataTypeDesign::
DataTypeDesign (const DataTypeDesign& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::TypeDesign (x, f, c),
  Fields_ (x.Fields_, f, this),
  Encodings_ (x.Encodings_, f, this),
  NoArraysAllowed_ (x.NoArraysAllowed_, f, this),
  NotInAddressSpace_ (x.NotInAddressSpace_, f, this)
{
}

DataTypeDesign::
DataTypeDesign (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::TypeDesign (e, f | ::xml_schema::flags::base, c),
  Fields_ (this),
  Encodings_ (this),
  NoArraysAllowed_ (this),
  NotInAddressSpace_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void DataTypeDesign::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::TypeDesign::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Fields
    //
    if (n.name () == "Fields" && n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
    {
      ::std::auto_ptr< Fields_type > r (
        Fields_traits::create (i, f, this));

      if (!this->Fields_)
      {
        this->Fields_.set (r);
        continue;
      }
    }

    // Encodings
    //
    if (n.name () == "Encodings" && n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
    {
      ::std::auto_ptr< Encodings_type > r (
        Encodings_traits::create (i, f, this));

      if (!this->Encodings_)
      {
        this->Encodings_.set (r);
        continue;
      }
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "NoArraysAllowed" && n.namespace_ ().empty ())
    {
      this->NoArraysAllowed_.set (NoArraysAllowed_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "NotInAddressSpace" && n.namespace_ ().empty ())
    {
      this->NotInAddressSpace_.set (NotInAddressSpace_traits::create (i, f, this));
      continue;
    }
  }

  if (!NoArraysAllowed_.present ())
  {
    this->NoArraysAllowed_.set (NoArraysAllowed_default_value ());
  }

  if (!NotInAddressSpace_.present ())
  {
    this->NotInAddressSpace_.set (NotInAddressSpace_default_value ());
  }
}

DataTypeDesign* DataTypeDesign::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class DataTypeDesign (*this, f, c);
}

DataTypeDesign& DataTypeDesign::
operator= (const DataTypeDesign& x)
{
  if (this != &x)
  {
    static_cast< ::TypeDesign& > (*this) = x;
    this->Fields_ = x.Fields_;
    this->Encodings_ = x.Encodings_;
    this->NoArraysAllowed_ = x.NoArraysAllowed_;
    this->NotInAddressSpace_ = x.NotInAddressSpace_;
  }

  return *this;
}

DataTypeDesign::
~DataTypeDesign ()
{
}

// ReferenceTypeDesign
//

ReferenceTypeDesign::
ReferenceTypeDesign ()
: ::TypeDesign (),
  InverseName_ (this),
  Symmetric_ (this)
{
}

ReferenceTypeDesign::
ReferenceTypeDesign (const ReferenceTypeDesign& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::TypeDesign (x, f, c),
  InverseName_ (x.InverseName_, f, this),
  Symmetric_ (x.Symmetric_, f, this)
{
}

ReferenceTypeDesign::
ReferenceTypeDesign (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::TypeDesign (e, f | ::xml_schema::flags::base, c),
  InverseName_ (this),
  Symmetric_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void ReferenceTypeDesign::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::TypeDesign::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // InverseName
    //
    if (n.name () == "InverseName" && n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
    {
      ::std::auto_ptr< InverseName_type > r (
        InverseName_traits::create (i, f, this));

      if (!this->InverseName_)
      {
        this->InverseName_.set (r);
        continue;
      }
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Symmetric" && n.namespace_ ().empty ())
    {
      this->Symmetric_.set (Symmetric_traits::create (i, f, this));
      continue;
    }
  }
}

ReferenceTypeDesign* ReferenceTypeDesign::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ReferenceTypeDesign (*this, f, c);
}

ReferenceTypeDesign& ReferenceTypeDesign::
operator= (const ReferenceTypeDesign& x)
{
  if (this != &x)
  {
    static_cast< ::TypeDesign& > (*this) = x;
    this->InverseName_ = x.InverseName_;
    this->Symmetric_ = x.Symmetric_;
  }

  return *this;
}

ReferenceTypeDesign::
~ReferenceTypeDesign ()
{
}

// InstanceDesign
//

InstanceDesign::
InstanceDesign ()
: ::NodeDesign (),
  ReferenceType_ (this),
  Declaration_ (this),
  TypeDefinition_ (this),
  ModellingRule_ (this),
  MinCardinality_ (MinCardinality_default_value (), this),
  MaxCardinality_ (MaxCardinality_default_value (), this),
  PreserveDefaultAttributes_ (PreserveDefaultAttributes_default_value (), this)
{
}

InstanceDesign::
InstanceDesign (const InstanceDesign& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::NodeDesign (x, f, c),
  ReferenceType_ (x.ReferenceType_, f, this),
  Declaration_ (x.Declaration_, f, this),
  TypeDefinition_ (x.TypeDefinition_, f, this),
  ModellingRule_ (x.ModellingRule_, f, this),
  MinCardinality_ (x.MinCardinality_, f, this),
  MaxCardinality_ (x.MaxCardinality_, f, this),
  PreserveDefaultAttributes_ (x.PreserveDefaultAttributes_, f, this)
{
}

InstanceDesign::
InstanceDesign (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::NodeDesign (e, f | ::xml_schema::flags::base, c),
  ReferenceType_ (this),
  Declaration_ (this),
  TypeDefinition_ (this),
  ModellingRule_ (this),
  MinCardinality_ (this),
  MaxCardinality_ (this),
  PreserveDefaultAttributes_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void InstanceDesign::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::NodeDesign::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ReferenceType
    //
    if (n.name () == "ReferenceType" && n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
    {
      ::std::auto_ptr< ReferenceType_type > r (
        ReferenceType_traits::create (i, f, this));

      if (!this->ReferenceType_)
      {
        this->ReferenceType_.set (r);
        continue;
      }
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Declaration" && n.namespace_ ().empty ())
    {
      this->Declaration_.set (Declaration_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "TypeDefinition" && n.namespace_ ().empty ())
    {
      this->TypeDefinition_.set (TypeDefinition_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "ModellingRule" && n.namespace_ ().empty ())
    {
      this->ModellingRule_.set (ModellingRule_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "MinCardinality" && n.namespace_ ().empty ())
    {
      this->MinCardinality_.set (MinCardinality_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "MaxCardinality" && n.namespace_ ().empty ())
    {
      this->MaxCardinality_.set (MaxCardinality_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "PreserveDefaultAttributes" && n.namespace_ ().empty ())
    {
      this->PreserveDefaultAttributes_.set (PreserveDefaultAttributes_traits::create (i, f, this));
      continue;
    }
  }

  if (!MinCardinality_.present ())
  {
    this->MinCardinality_.set (MinCardinality_default_value ());
  }

  if (!MaxCardinality_.present ())
  {
    this->MaxCardinality_.set (MaxCardinality_default_value ());
  }

  if (!PreserveDefaultAttributes_.present ())
  {
    this->PreserveDefaultAttributes_.set (PreserveDefaultAttributes_default_value ());
  }
}

InstanceDesign* InstanceDesign::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class InstanceDesign (*this, f, c);
}

InstanceDesign& InstanceDesign::
operator= (const InstanceDesign& x)
{
  if (this != &x)
  {
    static_cast< ::NodeDesign& > (*this) = x;
    this->ReferenceType_ = x.ReferenceType_;
    this->Declaration_ = x.Declaration_;
    this->TypeDefinition_ = x.TypeDefinition_;
    this->ModellingRule_ = x.ModellingRule_;
    this->MinCardinality_ = x.MinCardinality_;
    this->MaxCardinality_ = x.MaxCardinality_;
    this->PreserveDefaultAttributes_ = x.PreserveDefaultAttributes_;
  }

  return *this;
}

InstanceDesign::
~InstanceDesign ()
{
}

// ViewDesign
//

ViewDesign::
ViewDesign ()
: ::InstanceDesign (),
  SupportsEvents_ (SupportsEvents_default_value (), this),
  ContainsNoLoops_ (ContainsNoLoops_default_value (), this)
{
}

ViewDesign::
ViewDesign (const ViewDesign& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::InstanceDesign (x, f, c),
  SupportsEvents_ (x.SupportsEvents_, f, this),
  ContainsNoLoops_ (x.ContainsNoLoops_, f, this)
{
}

ViewDesign::
ViewDesign (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::InstanceDesign (e, f | ::xml_schema::flags::base, c),
  SupportsEvents_ (this),
  ContainsNoLoops_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void ViewDesign::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::InstanceDesign::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "SupportsEvents" && n.namespace_ ().empty ())
    {
      this->SupportsEvents_.set (SupportsEvents_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "ContainsNoLoops" && n.namespace_ ().empty ())
    {
      this->ContainsNoLoops_.set (ContainsNoLoops_traits::create (i, f, this));
      continue;
    }
  }

  if (!SupportsEvents_.present ())
  {
    this->SupportsEvents_.set (SupportsEvents_default_value ());
  }

  if (!ContainsNoLoops_.present ())
  {
    this->ContainsNoLoops_.set (ContainsNoLoops_default_value ());
  }
}

ViewDesign* ViewDesign::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ViewDesign (*this, f, c);
}

ViewDesign& ViewDesign::
operator= (const ViewDesign& x)
{
  if (this != &x)
  {
    static_cast< ::InstanceDesign& > (*this) = x;
    this->SupportsEvents_ = x.SupportsEvents_;
    this->ContainsNoLoops_ = x.ContainsNoLoops_;
  }

  return *this;
}

ViewDesign::
~ViewDesign ()
{
}

// ObjectDesign
//

ObjectDesign::
ObjectDesign ()
: ::InstanceDesign (),
  SupportsEvents_ (this)
{
}

ObjectDesign::
ObjectDesign (const ObjectDesign& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::InstanceDesign (x, f, c),
  SupportsEvents_ (x.SupportsEvents_, f, this)
{
}

ObjectDesign::
ObjectDesign (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::InstanceDesign (e, f | ::xml_schema::flags::base, c),
  SupportsEvents_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void ObjectDesign::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::InstanceDesign::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "SupportsEvents" && n.namespace_ ().empty ())
    {
      this->SupportsEvents_.set (SupportsEvents_traits::create (i, f, this));
      continue;
    }
  }
}

ObjectDesign* ObjectDesign::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ObjectDesign (*this, f, c);
}

ObjectDesign& ObjectDesign::
operator= (const ObjectDesign& x)
{
  if (this != &x)
  {
    static_cast< ::InstanceDesign& > (*this) = x;
    this->SupportsEvents_ = x.SupportsEvents_;
  }

  return *this;
}

ObjectDesign::
~ObjectDesign ()
{
}

// VariableDesign
//

VariableDesign::
VariableDesign ()
: ::InstanceDesign (),
  DefaultValue_ (this),
  DataType_ (this),
  ValueRank_ (this),
  ArrayDimensions_ (this),
  AccessLevel_ (this),
  MinimumSamplingInterval_ (this),
  Historizing_ (this)
{
}

VariableDesign::
VariableDesign (const VariableDesign& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::InstanceDesign (x, f, c),
  DefaultValue_ (x.DefaultValue_, f, this),
  DataType_ (x.DataType_, f, this),
  ValueRank_ (x.ValueRank_, f, this),
  ArrayDimensions_ (x.ArrayDimensions_, f, this),
  AccessLevel_ (x.AccessLevel_, f, this),
  MinimumSamplingInterval_ (x.MinimumSamplingInterval_, f, this),
  Historizing_ (x.Historizing_, f, this)
{
}

VariableDesign::
VariableDesign (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::InstanceDesign (e, f | ::xml_schema::flags::base, c),
  DefaultValue_ (this),
  DataType_ (this),
  ValueRank_ (this),
  ArrayDimensions_ (this),
  AccessLevel_ (this),
  MinimumSamplingInterval_ (this),
  Historizing_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void VariableDesign::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::InstanceDesign::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // DefaultValue
    //
    if (n.name () == "DefaultValue" && n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
    {
      ::std::auto_ptr< DefaultValue_type > r (
        DefaultValue_traits::create (i, f, this));

      if (!this->DefaultValue_)
      {
        this->DefaultValue_.set (r);
        continue;
      }
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "DataType" && n.namespace_ ().empty ())
    {
      this->DataType_.set (DataType_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "ValueRank" && n.namespace_ ().empty ())
    {
      this->ValueRank_.set (ValueRank_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "ArrayDimensions" && n.namespace_ ().empty ())
    {
      this->ArrayDimensions_.set (ArrayDimensions_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "AccessLevel" && n.namespace_ ().empty ())
    {
      this->AccessLevel_.set (AccessLevel_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "MinimumSamplingInterval" && n.namespace_ ().empty ())
    {
      this->MinimumSamplingInterval_.set (MinimumSamplingInterval_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Historizing" && n.namespace_ ().empty ())
    {
      this->Historizing_.set (Historizing_traits::create (i, f, this));
      continue;
    }
  }
}

VariableDesign* VariableDesign::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class VariableDesign (*this, f, c);
}

VariableDesign& VariableDesign::
operator= (const VariableDesign& x)
{
  if (this != &x)
  {
    static_cast< ::InstanceDesign& > (*this) = x;
    this->DefaultValue_ = x.DefaultValue_;
    this->DataType_ = x.DataType_;
    this->ValueRank_ = x.ValueRank_;
    this->ArrayDimensions_ = x.ArrayDimensions_;
    this->AccessLevel_ = x.AccessLevel_;
    this->MinimumSamplingInterval_ = x.MinimumSamplingInterval_;
    this->Historizing_ = x.Historizing_;
  }

  return *this;
}

VariableDesign::
~VariableDesign ()
{
}

// MethodDesign
//

MethodDesign::
MethodDesign ()
: ::InstanceDesign (),
  InputArguments_ (this),
  OutputArguments_ (this),
  NonExecutable_ (this)
{
}

MethodDesign::
MethodDesign (const MethodDesign& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::InstanceDesign (x, f, c),
  InputArguments_ (x.InputArguments_, f, this),
  OutputArguments_ (x.OutputArguments_, f, this),
  NonExecutable_ (x.NonExecutable_, f, this)
{
}

MethodDesign::
MethodDesign (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::InstanceDesign (e, f | ::xml_schema::flags::base, c),
  InputArguments_ (this),
  OutputArguments_ (this),
  NonExecutable_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void MethodDesign::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::InstanceDesign::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // InputArguments
    //
    if (n.name () == "InputArguments" && n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
    {
      ::std::auto_ptr< InputArguments_type > r (
        InputArguments_traits::create (i, f, this));

      if (!this->InputArguments_)
      {
        this->InputArguments_.set (r);
        continue;
      }
    }

    // OutputArguments
    //
    if (n.name () == "OutputArguments" && n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
    {
      ::std::auto_ptr< OutputArguments_type > r (
        OutputArguments_traits::create (i, f, this));

      if (!this->OutputArguments_)
      {
        this->OutputArguments_.set (r);
        continue;
      }
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "NonExecutable" && n.namespace_ ().empty ())
    {
      this->NonExecutable_.set (NonExecutable_traits::create (i, f, this));
      continue;
    }
  }
}

MethodDesign* MethodDesign::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MethodDesign (*this, f, c);
}

MethodDesign& MethodDesign::
operator= (const MethodDesign& x)
{
  if (this != &x)
  {
    static_cast< ::InstanceDesign& > (*this) = x;
    this->InputArguments_ = x.InputArguments_;
    this->OutputArguments_ = x.OutputArguments_;
    this->NonExecutable_ = x.NonExecutable_;
  }

  return *this;
}

MethodDesign::
~MethodDesign ()
{
}

// PropertyDesign
//

PropertyDesign::
PropertyDesign ()
: ::VariableDesign ()
{
}

PropertyDesign::
PropertyDesign (const PropertyDesign& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::VariableDesign (x, f, c)
{
}

PropertyDesign::
PropertyDesign (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::VariableDesign (e, f, c)
{
}

PropertyDesign* PropertyDesign::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PropertyDesign (*this, f, c);
}

PropertyDesign::
~PropertyDesign ()
{
}

// EncodingDesign
//

EncodingDesign::
EncodingDesign ()
: ::ObjectDesign ()
{
}

EncodingDesign::
EncodingDesign (const EncodingDesign& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::ObjectDesign (x, f, c)
{
}

EncodingDesign::
EncodingDesign (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::ObjectDesign (e, f, c)
{
}

EncodingDesign* EncodingDesign::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class EncodingDesign (*this, f, c);
}

EncodingDesign::
~EncodingDesign ()
{
}

// DictionaryDesign
//

DictionaryDesign::
DictionaryDesign (const EncodingName_type& EncodingName)
: ::VariableDesign (),
  EncodingName_ (EncodingName, this)
{
}

DictionaryDesign::
DictionaryDesign (const DictionaryDesign& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::VariableDesign (x, f, c),
  EncodingName_ (x.EncodingName_, f, this)
{
}

DictionaryDesign::
DictionaryDesign (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::VariableDesign (e, f | ::xml_schema::flags::base, c),
  EncodingName_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void DictionaryDesign::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::VariableDesign::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "EncodingName" && n.namespace_ ().empty ())
    {
      this->EncodingName_.set (EncodingName_traits::create (i, f, this));
      continue;
    }
  }

  if (!EncodingName_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "EncodingName",
      "");
  }
}

DictionaryDesign* DictionaryDesign::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class DictionaryDesign (*this, f, c);
}

DictionaryDesign& DictionaryDesign::
operator= (const DictionaryDesign& x)
{
  if (this != &x)
  {
    static_cast< ::VariableDesign& > (*this) = x;
    this->EncodingName_ = x.EncodingName_;
  }

  return *this;
}

DictionaryDesign::
~DictionaryDesign ()
{
}

// Reference
//

Reference::
Reference (const ReferenceType_type& ReferenceType,
           const TargetId_type& TargetId)
: ::xml_schema::type (),
  ReferenceType_ (ReferenceType, this),
  TargetId_ (TargetId, this),
  IsInverse_ (IsInverse_default_value (), this),
  IsOneWay_ (IsOneWay_default_value (), this)
{
}

Reference::
Reference (const Reference& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  ReferenceType_ (x.ReferenceType_, f, this),
  TargetId_ (x.TargetId_, f, this),
  IsInverse_ (x.IsInverse_, f, this),
  IsOneWay_ (x.IsOneWay_, f, this)
{
}

Reference::
Reference (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  ReferenceType_ (this),
  TargetId_ (this),
  IsInverse_ (this),
  IsOneWay_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void Reference::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ReferenceType
    //
    if (n.name () == "ReferenceType" && n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
    {
      ::std::auto_ptr< ReferenceType_type > r (
        ReferenceType_traits::create (i, f, this));

      if (!ReferenceType_.present ())
      {
        this->ReferenceType_.set (r);
        continue;
      }
    }

    // TargetId
    //
    if (n.name () == "TargetId" && n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
    {
      ::std::auto_ptr< TargetId_type > r (
        TargetId_traits::create (i, f, this));

      if (!TargetId_.present ())
      {
        this->TargetId_.set (r);
        continue;
      }
    }

    break;
  }

  if (!ReferenceType_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ReferenceType",
      "http://opcfoundation.org/UA/ModelDesign.xsd");
  }

  if (!TargetId_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "TargetId",
      "http://opcfoundation.org/UA/ModelDesign.xsd");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "IsInverse" && n.namespace_ ().empty ())
    {
      this->IsInverse_.set (IsInverse_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IsOneWay" && n.namespace_ ().empty ())
    {
      this->IsOneWay_.set (IsOneWay_traits::create (i, f, this));
      continue;
    }
  }

  if (!IsInverse_.present ())
  {
    this->IsInverse_.set (IsInverse_default_value ());
  }

  if (!IsOneWay_.present ())
  {
    this->IsOneWay_.set (IsOneWay_default_value ());
  }
}

Reference* Reference::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Reference (*this, f, c);
}

Reference& Reference::
operator= (const Reference& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->ReferenceType_ = x.ReferenceType_;
    this->TargetId_ = x.TargetId_;
    this->IsInverse_ = x.IsInverse_;
    this->IsOneWay_ = x.IsOneWay_;
  }

  return *this;
}

Reference::
~Reference ()
{
}

// ListOfReferences
//

ListOfReferences::
ListOfReferences ()
: ::xml_schema::type (),
  Reference_ (this)
{
}

ListOfReferences::
ListOfReferences (const ListOfReferences& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Reference_ (x.Reference_, f, this)
{
}

ListOfReferences::
ListOfReferences (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Reference_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ListOfReferences::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Reference
    //
    if (n.name () == "Reference" && n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
    {
      ::std::auto_ptr< Reference_type > r (
        Reference_traits::create (i, f, this));

      this->Reference_.push_back (r);
      continue;
    }

    break;
  }
}

ListOfReferences* ListOfReferences::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ListOfReferences (*this, f, c);
}

ListOfReferences& ListOfReferences::
operator= (const ListOfReferences& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Reference_ = x.Reference_;
  }

  return *this;
}

ListOfReferences::
~ListOfReferences ()
{
}

// Parameter
//

const Parameter::ValueRank_type Parameter::ValueRank_default_value_ (
  "Scalar");

Parameter::
Parameter ()
: ::xml_schema::type (),
  Description_ (this),
  Name_ (this),
  Identifier_ (this),
  DataType_ (this),
  ValueRank_ (ValueRank_default_value (), this),
  ArrayDimensions_ (this)
{
}

Parameter::
Parameter (const Parameter& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Description_ (x.Description_, f, this),
  Name_ (x.Name_, f, this),
  Identifier_ (x.Identifier_, f, this),
  DataType_ (x.DataType_, f, this),
  ValueRank_ (x.ValueRank_, f, this),
  ArrayDimensions_ (x.ArrayDimensions_, f, this)
{
}

Parameter::
Parameter (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Description_ (this),
  Name_ (this),
  Identifier_ (this),
  DataType_ (this),
  ValueRank_ (this),
  ArrayDimensions_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void Parameter::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Description
    //
    if (n.name () == "Description" && n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
    {
      ::std::auto_ptr< Description_type > r (
        Description_traits::create (i, f, this));

      if (!this->Description_)
      {
        this->Description_.set (r);
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      this->Name_.set (Name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Identifier" && n.namespace_ ().empty ())
    {
      this->Identifier_.set (Identifier_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "DataType" && n.namespace_ ().empty ())
    {
      this->DataType_.set (DataType_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "ValueRank" && n.namespace_ ().empty ())
    {
      this->ValueRank_.set (ValueRank_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "ArrayDimensions" && n.namespace_ ().empty ())
    {
      this->ArrayDimensions_.set (ArrayDimensions_traits::create (i, f, this));
      continue;
    }
  }

  if (!ValueRank_.present ())
  {
    this->ValueRank_.set (ValueRank_default_value ());
  }
}

Parameter* Parameter::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Parameter (*this, f, c);
}

Parameter& Parameter::
operator= (const Parameter& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Description_ = x.Description_;
    this->Name_ = x.Name_;
    this->Identifier_ = x.Identifier_;
    this->DataType_ = x.DataType_;
    this->ValueRank_ = x.ValueRank_;
    this->ArrayDimensions_ = x.ArrayDimensions_;
  }

  return *this;
}

Parameter::
~Parameter ()
{
}

// ListOfArguments
//

ListOfArguments::
ListOfArguments ()
: ::xml_schema::type (),
  Argument_ (this)
{
}

ListOfArguments::
ListOfArguments (const ListOfArguments& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Argument_ (x.Argument_, f, this)
{
}

ListOfArguments::
ListOfArguments (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Argument_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ListOfArguments::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Argument
    //
    if (n.name () == "Argument" && n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
    {
      ::std::auto_ptr< Argument_type > r (
        Argument_traits::create (i, f, this));

      this->Argument_.push_back (r);
      continue;
    }

    break;
  }
}

ListOfArguments* ListOfArguments::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ListOfArguments (*this, f, c);
}

ListOfArguments& ListOfArguments::
operator= (const ListOfArguments& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Argument_ = x.Argument_;
  }

  return *this;
}

ListOfArguments::
~ListOfArguments ()
{
}

// ListOfFields
//

ListOfFields::
ListOfFields ()
: ::xml_schema::type (),
  Field_ (this)
{
}

ListOfFields::
ListOfFields (const ListOfFields& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Field_ (x.Field_, f, this)
{
}

ListOfFields::
ListOfFields (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Field_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ListOfFields::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Field
    //
    if (n.name () == "Field" && n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
    {
      ::std::auto_ptr< Field_type > r (
        Field_traits::create (i, f, this));

      this->Field_.push_back (r);
      continue;
    }

    break;
  }
}

ListOfFields* ListOfFields::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ListOfFields (*this, f, c);
}

ListOfFields& ListOfFields::
operator= (const ListOfFields& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Field_ = x.Field_;
  }

  return *this;
}

ListOfFields::
~ListOfFields ()
{
}

// ListOfEncodings
//

ListOfEncodings::
ListOfEncodings ()
: ::xml_schema::type (),
  Encoding_ (this)
{
}

ListOfEncodings::
ListOfEncodings (const ListOfEncodings& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Encoding_ (x.Encoding_, f, this)
{
}

ListOfEncodings::
ListOfEncodings (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Encoding_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ListOfEncodings::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Encoding
    //
    if (n.name () == "Encoding" && n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
    {
      ::std::auto_ptr< Encoding_type > r (
        Encoding_traits::create (i, f, this));

      this->Encoding_.push_back (r);
      continue;
    }

    break;
  }
}

ListOfEncodings* ListOfEncodings::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ListOfEncodings (*this, f, c);
}

ListOfEncodings& ListOfEncodings::
operator= (const ListOfEncodings& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Encoding_ = x.Encoding_;
  }

  return *this;
}

ListOfEncodings::
~ListOfEncodings ()
{
}

// ListOfChildren
//

ListOfChildren::
ListOfChildren ()
: ::xml_schema::type (),
  Object_ (this),
  Variable_ (this),
  Property_ (this),
  Method_ (this)
{
}

ListOfChildren::
ListOfChildren (const ListOfChildren& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Object_ (x.Object_, f, this),
  Variable_ (x.Variable_, f, this),
  Property_ (x.Property_, f, this),
  Method_ (x.Method_, f, this)
{
}

ListOfChildren::
ListOfChildren (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Object_ (this),
  Variable_ (this),
  Property_ (this),
  Method_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ListOfChildren::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Object
    //
    if (n.name () == "Object" && n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
    {
      ::std::auto_ptr< Object_type > r (
        Object_traits::create (i, f, this));

      this->Object_.push_back (r);
      continue;
    }

    // Variable
    //
    if (n.name () == "Variable" && n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
    {
      ::std::auto_ptr< Variable_type > r (
        Variable_traits::create (i, f, this));

      this->Variable_.push_back (r);
      continue;
    }

    // Property
    //
    if (n.name () == "Property" && n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
    {
      ::std::auto_ptr< Property_type > r (
        Property_traits::create (i, f, this));

      this->Property_.push_back (r);
      continue;
    }

    // Method
    //
    if (n.name () == "Method" && n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
    {
      ::std::auto_ptr< Method_type > r (
        Method_traits::create (i, f, this));

      this->Method_.push_back (r);
      continue;
    }

    break;
  }
}

ListOfChildren* ListOfChildren::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ListOfChildren (*this, f, c);
}

ListOfChildren& ListOfChildren::
operator= (const ListOfChildren& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Object_ = x.Object_;
    this->Variable_ = x.Variable_;
    this->Property_ = x.Property_;
    this->Method_ = x.Method_;
  }

  return *this;
}

ListOfChildren::
~ListOfChildren ()
{
}

// LocalizedText
//

const LocalizedText::Key_type LocalizedText::Key_default_value_ (
  "");

LocalizedText::
LocalizedText ()
: ::xml_schema::string (),
  Key_ (Key_default_value (), this)
{
}

LocalizedText::
LocalizedText (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  Key_ (Key_default_value (), this)
{
}

LocalizedText::
LocalizedText (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  Key_ (Key_default_value (), this)
{
}

LocalizedText::
LocalizedText (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  Key_ (Key_default_value (), this)
{
}

LocalizedText::
LocalizedText (const LocalizedText& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  Key_ (x.Key_, f, this)
{
}

LocalizedText::
LocalizedText (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  Key_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void LocalizedText::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Key" && n.namespace_ ().empty ())
    {
      this->Key_.set (Key_traits::create (i, f, this));
      continue;
    }
  }

  if (!Key_.present ())
  {
    this->Key_.set (Key_default_value ());
  }
}

LocalizedText* LocalizedText::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class LocalizedText (*this, f, c);
}

LocalizedText& LocalizedText::
operator= (const LocalizedText& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->Key_ = x.Key_;
  }

  return *this;
}

LocalizedText::
~LocalizedText ()
{
}

// DefaultValue
//

DefaultValue::
DefaultValue ()
: ::xml_schema::type ()
{
}

DefaultValue::
DefaultValue (const DefaultValue& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c)
{
}

DefaultValue::
DefaultValue (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void DefaultValue::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    break;
  }
}

DefaultValue* DefaultValue::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class DefaultValue (*this, f, c);
}

DefaultValue::
~DefaultValue ()
{
}

// AccessLevel
//

AccessLevel::
AccessLevel (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_AccessLevel_convert ();
}

AccessLevel::
AccessLevel (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_AccessLevel_convert ();
}

AccessLevel::
AccessLevel (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_AccessLevel_convert ();
}

AccessLevel* AccessLevel::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class AccessLevel (*this, f, c);
}

AccessLevel::value AccessLevel::
_xsd_AccessLevel_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_AccessLevel_literals_);
  const value* i (::std::lower_bound (
                    _xsd_AccessLevel_indexes_,
                    _xsd_AccessLevel_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_AccessLevel_indexes_ + 4 || _xsd_AccessLevel_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const AccessLevel::
_xsd_AccessLevel_literals_[4] =
{
  "None",
  "Read",
  "Write",
  "ReadWrite"
};

const AccessLevel::value AccessLevel::
_xsd_AccessLevel_indexes_[4] =
{
  ::AccessLevel::None,
  ::AccessLevel::Read,
  ::AccessLevel::ReadWrite,
  ::AccessLevel::Write
};

// ValueRank
//

ValueRank::
ValueRank (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_ValueRank_convert ();
}

ValueRank::
ValueRank (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_ValueRank_convert ();
}

ValueRank::
ValueRank (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_ValueRank_convert ();
}

ValueRank* ValueRank::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ValueRank (*this, f, c);
}

ValueRank::value ValueRank::
_xsd_ValueRank_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ValueRank_literals_);
  const value* i (::std::lower_bound (
                    _xsd_ValueRank_indexes_,
                    _xsd_ValueRank_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_ValueRank_indexes_ + 4 || _xsd_ValueRank_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const ValueRank::
_xsd_ValueRank_literals_[4] =
{
  "Scalar",
  "Array",
  "ScalarOrArray",
  "OneOrMoreDimensions"
};

const ValueRank::value ValueRank::
_xsd_ValueRank_indexes_[4] =
{
  ::ValueRank::Array,
  ::ValueRank::OneOrMoreDimensions,
  ::ValueRank::Scalar,
  ::ValueRank::ScalarOrArray
};

// ModellingRule
//

ModellingRule::
ModellingRule (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_ModellingRule_convert ();
}

ModellingRule::
ModellingRule (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_ModellingRule_convert ();
}

ModellingRule::
ModellingRule (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_ModellingRule_convert ();
}

ModellingRule* ModellingRule::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ModellingRule (*this, f, c);
}

ModellingRule::value ModellingRule::
_xsd_ModellingRule_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ModellingRule_literals_);
  const value* i (::std::lower_bound (
                    _xsd_ModellingRule_indexes_,
                    _xsd_ModellingRule_indexes_ + 8,
                    *this,
                    c));

  if (i == _xsd_ModellingRule_indexes_ + 8 || _xsd_ModellingRule_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const ModellingRule::
_xsd_ModellingRule_literals_[8] =
{
  "None",
  "Mandatory",
  "Optional",
  "ExposesItsArray",
  "CardinalityRestriction",
  "MandatoryShared",
  "OptionalPlaceholder",
  "MandatoryPlaceholder"
};

const ModellingRule::value ModellingRule::
_xsd_ModellingRule_indexes_[8] =
{
  ::ModellingRule::CardinalityRestriction,
  ::ModellingRule::ExposesItsArray,
  ::ModellingRule::Mandatory,
  ::ModellingRule::MandatoryPlaceholder,
  ::ModellingRule::MandatoryShared,
  ::ModellingRule::None,
  ::ModellingRule::Optional,
  ::ModellingRule::OptionalPlaceholder
};

// ModelDesign
//

const ModelDesign::DefaultLocale_type ModelDesign::DefaultLocale_default_value_ (
  "en");

ModelDesign::
ModelDesign (const TargetNamespace_type& TargetNamespace)
: ::xml_schema::type (),
  Namespaces_ (this),
  VariableType_ (this),
  ReferenceType_ (this),
  DataType_ (this),
  Method_ (this),
  ObjectType_ (this),
  Object_ (this),
  Variable_ (this),
  Property_ (this),
  Dictionary_ (this),
  View_ (this),
  TargetNamespace_ (TargetNamespace, this),
  TargetVersion_ (this),
  TargetPublicationDate_ (this),
  TargetXmlNamespace_ (this),
  DefaultLocale_ (DefaultLocale_default_value (), this)
{
}

ModelDesign::
ModelDesign (const ModelDesign& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Namespaces_ (x.Namespaces_, f, this),
  VariableType_ (x.VariableType_, f, this),
  ReferenceType_ (x.ReferenceType_, f, this),
  DataType_ (x.DataType_, f, this),
  Method_ (x.Method_, f, this),
  ObjectType_ (x.ObjectType_, f, this),
  Object_ (x.Object_, f, this),
  Variable_ (x.Variable_, f, this),
  Property_ (x.Property_, f, this),
  Dictionary_ (x.Dictionary_, f, this),
  View_ (x.View_, f, this),
  TargetNamespace_ (x.TargetNamespace_, f, this),
  TargetVersion_ (x.TargetVersion_, f, this),
  TargetPublicationDate_ (x.TargetPublicationDate_, f, this),
  TargetXmlNamespace_ (x.TargetXmlNamespace_, f, this),
  DefaultLocale_ (x.DefaultLocale_, f, this)
{
}

ModelDesign::
ModelDesign (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Namespaces_ (this),
  VariableType_ (this),
  ReferenceType_ (this),
  DataType_ (this),
  Method_ (this),
  ObjectType_ (this),
  Object_ (this),
  Variable_ (this),
  Property_ (this),
  Dictionary_ (this),
  View_ (this),
  TargetNamespace_ (this),
  TargetVersion_ (this),
  TargetPublicationDate_ (this),
  TargetXmlNamespace_ (this),
  DefaultLocale_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void ModelDesign::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Namespaces
    //
    if (n.name () == "Namespaces" && n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
    {
      ::std::auto_ptr< Namespaces_type > r (
        Namespaces_traits::create (i, f, this));

      if (!this->Namespaces_)
      {
        this->Namespaces_.set (r);
        continue;
      }
    }

    // VariableType
    //
    if (n.name () == "VariableType" && n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
    {
      ::std::auto_ptr< VariableType_type > r (
        VariableType_traits::create (i, f, this));

      this->VariableType_.push_back (r);
      continue;
    }

    // ReferenceType
    //
    if (n.name () == "ReferenceType" && n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
    {
      ::std::auto_ptr< ReferenceType_type > r (
        ReferenceType_traits::create (i, f, this));

      this->ReferenceType_.push_back (r);
      continue;
    }

    // DataType
    //
    if (n.name () == "DataType" && n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
    {
      ::std::auto_ptr< DataType_type > r (
        DataType_traits::create (i, f, this));

      this->DataType_.push_back (r);
      continue;
    }

    // Method
    //
    if (n.name () == "Method" && n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
    {
      ::std::auto_ptr< Method_type > r (
        Method_traits::create (i, f, this));

      this->Method_.push_back (r);
      continue;
    }

    // ObjectType
    //
    if (n.name () == "ObjectType" && n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
    {
      ::std::auto_ptr< ObjectType_type > r (
        ObjectType_traits::create (i, f, this));

      this->ObjectType_.push_back (r);
      continue;
    }

    // Object
    //
    if (n.name () == "Object" && n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
    {
      ::std::auto_ptr< Object_type > r (
        Object_traits::create (i, f, this));

      this->Object_.push_back (r);
      continue;
    }

    // Variable
    //
    if (n.name () == "Variable" && n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
    {
      ::std::auto_ptr< Variable_type > r (
        Variable_traits::create (i, f, this));

      this->Variable_.push_back (r);
      continue;
    }

    // Property
    //
    if (n.name () == "Property" && n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
    {
      ::std::auto_ptr< Property_type > r (
        Property_traits::create (i, f, this));

      this->Property_.push_back (r);
      continue;
    }

    // Dictionary
    //
    if (n.name () == "Dictionary" && n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
    {
      ::std::auto_ptr< Dictionary_type > r (
        Dictionary_traits::create (i, f, this));

      this->Dictionary_.push_back (r);
      continue;
    }

    // View
    //
    if (n.name () == "View" && n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
    {
      ::std::auto_ptr< View_type > r (
        View_traits::create (i, f, this));

      this->View_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "TargetNamespace" && n.namespace_ ().empty ())
    {
      this->TargetNamespace_.set (TargetNamespace_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "TargetVersion" && n.namespace_ ().empty ())
    {
      this->TargetVersion_.set (TargetVersion_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "TargetPublicationDate" && n.namespace_ ().empty ())
    {
      this->TargetPublicationDate_.set (TargetPublicationDate_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "TargetXmlNamespace" && n.namespace_ ().empty ())
    {
      this->TargetXmlNamespace_.set (TargetXmlNamespace_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "DefaultLocale" && n.namespace_ ().empty ())
    {
      this->DefaultLocale_.set (DefaultLocale_traits::create (i, f, this));
      continue;
    }
  }

  if (!TargetNamespace_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "TargetNamespace",
      "");
  }

  if (!DefaultLocale_.present ())
  {
    this->DefaultLocale_.set (DefaultLocale_default_value ());
  }
}

ModelDesign* ModelDesign::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ModelDesign (*this, f, c);
}

ModelDesign& ModelDesign::
operator= (const ModelDesign& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Namespaces_ = x.Namespaces_;
    this->VariableType_ = x.VariableType_;
    this->ReferenceType_ = x.ReferenceType_;
    this->DataType_ = x.DataType_;
    this->Method_ = x.Method_;
    this->ObjectType_ = x.ObjectType_;
    this->Object_ = x.Object_;
    this->Variable_ = x.Variable_;
    this->Property_ = x.Property_;
    this->Dictionary_ = x.Dictionary_;
    this->View_ = x.View_;
    this->TargetNamespace_ = x.TargetNamespace_;
    this->TargetVersion_ = x.TargetVersion_;
    this->TargetPublicationDate_ = x.TargetPublicationDate_;
    this->TargetXmlNamespace_ = x.TargetXmlNamespace_;
    this->DefaultLocale_ = x.DefaultLocale_;
  }

  return *this;
}

ModelDesign::
~ModelDesign ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::ModelDesign >
ModelDesign_ (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::ModelDesign > (
    ::ModelDesign_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::ModelDesign >
ModelDesign_ (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::ModelDesign > (
    ::ModelDesign_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::ModelDesign >
ModelDesign_ (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::ModelDesign > (
    ::ModelDesign_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::ModelDesign >
ModelDesign_ (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::ModelDesign_ (isrc, f, p);
}

::std::auto_ptr< ::ModelDesign >
ModelDesign_ (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::ModelDesign_ (isrc, h, f, p);
}

::std::auto_ptr< ::ModelDesign >
ModelDesign_ (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::ModelDesign_ (isrc, h, f, p);
}

::std::auto_ptr< ::ModelDesign >
ModelDesign_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::ModelDesign_ (isrc, f, p);
}

::std::auto_ptr< ::ModelDesign >
ModelDesign_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::ModelDesign_ (isrc, h, f, p);
}

::std::auto_ptr< ::ModelDesign >
ModelDesign_ (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::ModelDesign_ (isrc, h, f, p);
}

::std::auto_ptr< ::ModelDesign >
ModelDesign_ (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::ModelDesign > (
    ::ModelDesign_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::ModelDesign >
ModelDesign_ (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::ModelDesign > (
    ::ModelDesign_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::ModelDesign >
ModelDesign_ (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::ModelDesign > (
    ::ModelDesign_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::ModelDesign >
ModelDesign_ (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::ModelDesign > (
      ::ModelDesign_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "ModelDesign" &&
      n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
  {
    ::std::auto_ptr< ::ModelDesign > r (
      ::xsd::cxx::tree::traits< ::ModelDesign, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "ModelDesign",
    "http://opcfoundation.org/UA/ModelDesign.xsd");
}

::std::auto_ptr< ::ModelDesign >
ModelDesign_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "ModelDesign" &&
      n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
  {
    ::std::auto_ptr< ::ModelDesign > r (
      ::xsd::cxx::tree::traits< ::ModelDesign, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "ModelDesign",
    "http://opcfoundation.org/UA/ModelDesign.xsd");
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

void
ModelDesign_ (::std::ostream& o,
              const ::ModelDesign& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::ModelDesign_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
ModelDesign_ (::std::ostream& o,
              const ::ModelDesign& s,
              ::xml_schema::error_handler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::ModelDesign_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
ModelDesign_ (::std::ostream& o,
              const ::ModelDesign& s,
              ::xercesc::DOMErrorHandler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::ModelDesign_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
ModelDesign_ (::xercesc::XMLFormatTarget& t,
              const ::ModelDesign& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::ModelDesign_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
ModelDesign_ (::xercesc::XMLFormatTarget& t,
              const ::ModelDesign& s,
              ::xml_schema::error_handler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::ModelDesign_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
ModelDesign_ (::xercesc::XMLFormatTarget& t,
              const ::ModelDesign& s,
              ::xercesc::DOMErrorHandler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::ModelDesign_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
ModelDesign_ (::xercesc::DOMDocument& d,
              const ::ModelDesign& s,
              ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "ModelDesign" &&
      n.namespace_ () == "http://opcfoundation.org/UA/ModelDesign.xsd")
  {
    e << s;
  }
  else
  {
    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ModelDesign",
      "http://opcfoundation.org/UA/ModelDesign.xsd");
  }
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
ModelDesign_ (const ::ModelDesign& s,
              const ::xml_schema::namespace_infomap& m,
              ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::serialize< char > (
      "ModelDesign",
      "http://opcfoundation.org/UA/ModelDesign.xsd",
      m, f));

  ::ModelDesign_ (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const NamespaceTable& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Namespace
  //
  for (NamespaceTable::Namespace_const_iterator
       b (i.Namespace ().begin ()), n (i.Namespace ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Namespace",
        "http://opcfoundation.org/UA/ModelDesign.xsd",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const Namespace& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // Name
  //
  if (i.Name ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Name",
        e));

    a << *i.Name ();
  }

  // Prefix
  //
  if (i.Prefix ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Prefix",
        e));

    a << *i.Prefix ();
  }

  // InternalPrefix
  //
  if (i.InternalPrefix ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "InternalPrefix",
        e));

    a << *i.InternalPrefix ();
  }

  // XmlNamespace
  //
  if (i.XmlNamespace ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "XmlNamespace",
        e));

    a << *i.XmlNamespace ();
  }

  // XmlPrefix
  //
  if (i.XmlPrefix ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "XmlPrefix",
        e));

    a << *i.XmlPrefix ();
  }

  // FilePath
  //
  if (i.FilePath ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "FilePath",
        e));

    a << *i.FilePath ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const NodeDesign& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // BrowseName
  //
  if (i.BrowseName ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "BrowseName",
        "http://opcfoundation.org/UA/ModelDesign.xsd",
        e));

    s << *i.BrowseName ();
  }

  // DisplayName
  //
  if (i.DisplayName ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DisplayName",
        "http://opcfoundation.org/UA/ModelDesign.xsd",
        e));

    s << *i.DisplayName ();
  }

  // Description
  //
  if (i.Description ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Description",
        "http://opcfoundation.org/UA/ModelDesign.xsd",
        e));

    s << *i.Description ();
  }

  // Children
  //
  if (i.Children ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Children",
        "http://opcfoundation.org/UA/ModelDesign.xsd",
        e));

    s << *i.Children ();
  }

  // References
  //
  if (i.References ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "References",
        "http://opcfoundation.org/UA/ModelDesign.xsd",
        e));

    s << *i.References ();
  }

  // SymbolicName
  //
  if (i.SymbolicName ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "SymbolicName",
        e));

    a << *i.SymbolicName ();
  }

  // SymbolicId
  //
  if (i.SymbolicId ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "SymbolicId",
        e));

    a << *i.SymbolicId ();
  }

  // IsDeclaration
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "IsDeclaration",
        e));

    a << i.IsDeclaration ();
  }

  // NumericId
  //
  if (i.NumericId ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "NumericId",
        e));

    a << *i.NumericId ();
  }

  // StringId
  //
  if (i.StringId ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "StringId",
        e));

    a << *i.StringId ();
  }

  // WriteAccess
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "WriteAccess",
        e));

    a << i.WriteAccess ();
  }

  // PartNo
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "PartNo",
        e));

    a << i.PartNo ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const TypeDesign& i)
{
  e << static_cast< const ::NodeDesign& > (i);

  // ClassName
  //
  if (i.ClassName ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ClassName",
        "http://opcfoundation.org/UA/ModelDesign.xsd",
        e));

    s << *i.ClassName ();
  }

  // BaseType
  //
  if (i.BaseType ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "BaseType",
        e));

    a << *i.BaseType ();
  }

  // IsAbstract
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "IsAbstract",
        e));

    a << i.IsAbstract ();
  }

  // NoClassGeneration
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "NoClassGeneration",
        e));

    a << i.NoClassGeneration ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ObjectTypeDesign& i)
{
  e << static_cast< const ::TypeDesign& > (i);

  // SupportsEvents
  //
  if (i.SupportsEvents ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "SupportsEvents",
        e));

    a << *i.SupportsEvents ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const VariableTypeDesign& i)
{
  e << static_cast< const ::TypeDesign& > (i);

  // DefaultValue
  //
  if (i.DefaultValue ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DefaultValue",
        "http://opcfoundation.org/UA/ModelDesign.xsd",
        e));

    s << *i.DefaultValue ();
  }

  // DataType
  //
  if (i.DataType ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "DataType",
        e));

    a << *i.DataType ();
  }

  // ValueRank
  //
  if (i.ValueRank ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "ValueRank",
        e));

    a << *i.ValueRank ();
  }

  // ArrayDimensions
  //
  if (i.ArrayDimensions ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "ArrayDimensions",
        e));

    a << *i.ArrayDimensions ();
  }

  // AccessLevel
  //
  if (i.AccessLevel ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "AccessLevel",
        e));

    a << *i.AccessLevel ();
  }

  // MinimumSamplingInterval
  //
  if (i.MinimumSamplingInterval ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "MinimumSamplingInterval",
        e));

    a << *i.MinimumSamplingInterval ();
  }

  // Historizing
  //
  if (i.Historizing ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Historizing",
        e));

    a << *i.Historizing ();
  }

  // ExposesItsChildren
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "ExposesItsChildren",
        e));

    a << i.ExposesItsChildren ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const DataTypeDesign& i)
{
  e << static_cast< const ::TypeDesign& > (i);

  // Fields
  //
  if (i.Fields ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Fields",
        "http://opcfoundation.org/UA/ModelDesign.xsd",
        e));

    s << *i.Fields ();
  }

  // Encodings
  //
  if (i.Encodings ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Encodings",
        "http://opcfoundation.org/UA/ModelDesign.xsd",
        e));

    s << *i.Encodings ();
  }

  // NoArraysAllowed
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "NoArraysAllowed",
        e));

    a << i.NoArraysAllowed ();
  }

  // NotInAddressSpace
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "NotInAddressSpace",
        e));

    a << i.NotInAddressSpace ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ReferenceTypeDesign& i)
{
  e << static_cast< const ::TypeDesign& > (i);

  // InverseName
  //
  if (i.InverseName ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "InverseName",
        "http://opcfoundation.org/UA/ModelDesign.xsd",
        e));

    s << *i.InverseName ();
  }

  // Symmetric
  //
  if (i.Symmetric ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Symmetric",
        e));

    a << *i.Symmetric ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const InstanceDesign& i)
{
  e << static_cast< const ::NodeDesign& > (i);

  // ReferenceType
  //
  if (i.ReferenceType ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ReferenceType",
        "http://opcfoundation.org/UA/ModelDesign.xsd",
        e));

    s << *i.ReferenceType ();
  }

  // Declaration
  //
  if (i.Declaration ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Declaration",
        e));

    a << *i.Declaration ();
  }

  // TypeDefinition
  //
  if (i.TypeDefinition ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "TypeDefinition",
        e));

    a << *i.TypeDefinition ();
  }

  // ModellingRule
  //
  if (i.ModellingRule ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "ModellingRule",
        e));

    a << *i.ModellingRule ();
  }

  // MinCardinality
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "MinCardinality",
        e));

    a << i.MinCardinality ();
  }

  // MaxCardinality
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "MaxCardinality",
        e));

    a << i.MaxCardinality ();
  }

  // PreserveDefaultAttributes
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "PreserveDefaultAttributes",
        e));

    a << i.PreserveDefaultAttributes ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ViewDesign& i)
{
  e << static_cast< const ::InstanceDesign& > (i);

  // SupportsEvents
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "SupportsEvents",
        e));

    a << i.SupportsEvents ();
  }

  // ContainsNoLoops
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "ContainsNoLoops",
        e));

    a << i.ContainsNoLoops ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ObjectDesign& i)
{
  e << static_cast< const ::InstanceDesign& > (i);

  // SupportsEvents
  //
  if (i.SupportsEvents ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "SupportsEvents",
        e));

    a << *i.SupportsEvents ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const VariableDesign& i)
{
  e << static_cast< const ::InstanceDesign& > (i);

  // DefaultValue
  //
  if (i.DefaultValue ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DefaultValue",
        "http://opcfoundation.org/UA/ModelDesign.xsd",
        e));

    s << *i.DefaultValue ();
  }

  // DataType
  //
  if (i.DataType ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "DataType",
        e));

    a << *i.DataType ();
  }

  // ValueRank
  //
  if (i.ValueRank ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "ValueRank",
        e));

    a << *i.ValueRank ();
  }

  // ArrayDimensions
  //
  if (i.ArrayDimensions ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "ArrayDimensions",
        e));

    a << *i.ArrayDimensions ();
  }

  // AccessLevel
  //
  if (i.AccessLevel ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "AccessLevel",
        e));

    a << *i.AccessLevel ();
  }

  // MinimumSamplingInterval
  //
  if (i.MinimumSamplingInterval ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "MinimumSamplingInterval",
        e));

    a << *i.MinimumSamplingInterval ();
  }

  // Historizing
  //
  if (i.Historizing ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Historizing",
        e));

    a << *i.Historizing ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const MethodDesign& i)
{
  e << static_cast< const ::InstanceDesign& > (i);

  // InputArguments
  //
  if (i.InputArguments ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "InputArguments",
        "http://opcfoundation.org/UA/ModelDesign.xsd",
        e));

    s << *i.InputArguments ();
  }

  // OutputArguments
  //
  if (i.OutputArguments ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "OutputArguments",
        "http://opcfoundation.org/UA/ModelDesign.xsd",
        e));

    s << *i.OutputArguments ();
  }

  // NonExecutable
  //
  if (i.NonExecutable ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "NonExecutable",
        e));

    a << *i.NonExecutable ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const PropertyDesign& i)
{
  e << static_cast< const ::VariableDesign& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const EncodingDesign& i)
{
  e << static_cast< const ::ObjectDesign& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const DictionaryDesign& i)
{
  e << static_cast< const ::VariableDesign& > (i);

  // EncodingName
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "EncodingName",
        e));

    a << i.EncodingName ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Reference& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // ReferenceType
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ReferenceType",
        "http://opcfoundation.org/UA/ModelDesign.xsd",
        e));

    s << i.ReferenceType ();
  }

  // TargetId
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "TargetId",
        "http://opcfoundation.org/UA/ModelDesign.xsd",
        e));

    s << i.TargetId ();
  }

  // IsInverse
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "IsInverse",
        e));

    a << i.IsInverse ();
  }

  // IsOneWay
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "IsOneWay",
        e));

    a << i.IsOneWay ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ListOfReferences& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Reference
  //
  for (ListOfReferences::Reference_const_iterator
       b (i.Reference ().begin ()), n (i.Reference ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Reference",
        "http://opcfoundation.org/UA/ModelDesign.xsd",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const Parameter& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Description
  //
  if (i.Description ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Description",
        "http://opcfoundation.org/UA/ModelDesign.xsd",
        e));

    s << *i.Description ();
  }

  // Name
  //
  if (i.Name ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Name",
        e));

    a << *i.Name ();
  }

  // Identifier
  //
  if (i.Identifier ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Identifier",
        e));

    a << *i.Identifier ();
  }

  // DataType
  //
  if (i.DataType ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "DataType",
        e));

    a << *i.DataType ();
  }

  // ValueRank
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "ValueRank",
        e));

    a << i.ValueRank ();
  }

  // ArrayDimensions
  //
  if (i.ArrayDimensions ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "ArrayDimensions",
        e));

    a << *i.ArrayDimensions ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ListOfArguments& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Argument
  //
  for (ListOfArguments::Argument_const_iterator
       b (i.Argument ().begin ()), n (i.Argument ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Argument",
        "http://opcfoundation.org/UA/ModelDesign.xsd",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const ListOfFields& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Field
  //
  for (ListOfFields::Field_const_iterator
       b (i.Field ().begin ()), n (i.Field ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Field",
        "http://opcfoundation.org/UA/ModelDesign.xsd",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const ListOfEncodings& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Encoding
  //
  for (ListOfEncodings::Encoding_const_iterator
       b (i.Encoding ().begin ()), n (i.Encoding ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Encoding",
        "http://opcfoundation.org/UA/ModelDesign.xsd",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const ListOfChildren& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Object
  //
  for (ListOfChildren::Object_const_iterator
       b (i.Object ().begin ()), n (i.Object ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Object",
        "http://opcfoundation.org/UA/ModelDesign.xsd",
        e));

    s << *b;
  }

  // Variable
  //
  for (ListOfChildren::Variable_const_iterator
       b (i.Variable ().begin ()), n (i.Variable ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Variable",
        "http://opcfoundation.org/UA/ModelDesign.xsd",
        e));

    s << *b;
  }

  // Property
  //
  for (ListOfChildren::Property_const_iterator
       b (i.Property ().begin ()), n (i.Property ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Property",
        "http://opcfoundation.org/UA/ModelDesign.xsd",
        e));

    s << *b;
  }

  // Method
  //
  for (ListOfChildren::Method_const_iterator
       b (i.Method ().begin ()), n (i.Method ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Method",
        "http://opcfoundation.org/UA/ModelDesign.xsd",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const LocalizedText& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // Key
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Key",
        e));

    a << i.Key ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const DefaultValue& i)
{
  e << static_cast< const ::xml_schema::type& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const AccessLevel& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const AccessLevel& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const AccessLevel& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const ValueRank& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const ValueRank& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const ValueRank& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const ModellingRule& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const ModellingRule& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const ModellingRule& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const ModelDesign& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Namespaces
  //
  if (i.Namespaces ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Namespaces",
        "http://opcfoundation.org/UA/ModelDesign.xsd",
        e));

    s << *i.Namespaces ();
  }

  // VariableType
  //
  for (ModelDesign::VariableType_const_iterator
       b (i.VariableType ().begin ()), n (i.VariableType ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "VariableType",
        "http://opcfoundation.org/UA/ModelDesign.xsd",
        e));

    s << *b;
  }

  // ReferenceType
  //
  for (ModelDesign::ReferenceType_const_iterator
       b (i.ReferenceType ().begin ()), n (i.ReferenceType ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ReferenceType",
        "http://opcfoundation.org/UA/ModelDesign.xsd",
        e));

    s << *b;
  }

  // DataType
  //
  for (ModelDesign::DataType_const_iterator
       b (i.DataType ().begin ()), n (i.DataType ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DataType",
        "http://opcfoundation.org/UA/ModelDesign.xsd",
        e));

    s << *b;
  }

  // Method
  //
  for (ModelDesign::Method_const_iterator
       b (i.Method ().begin ()), n (i.Method ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Method",
        "http://opcfoundation.org/UA/ModelDesign.xsd",
        e));

    s << *b;
  }

  // ObjectType
  //
  for (ModelDesign::ObjectType_const_iterator
       b (i.ObjectType ().begin ()), n (i.ObjectType ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ObjectType",
        "http://opcfoundation.org/UA/ModelDesign.xsd",
        e));

    s << *b;
  }

  // Object
  //
  for (ModelDesign::Object_const_iterator
       b (i.Object ().begin ()), n (i.Object ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Object",
        "http://opcfoundation.org/UA/ModelDesign.xsd",
        e));

    s << *b;
  }

  // Variable
  //
  for (ModelDesign::Variable_const_iterator
       b (i.Variable ().begin ()), n (i.Variable ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Variable",
        "http://opcfoundation.org/UA/ModelDesign.xsd",
        e));

    s << *b;
  }

  // Property
  //
  for (ModelDesign::Property_const_iterator
       b (i.Property ().begin ()), n (i.Property ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Property",
        "http://opcfoundation.org/UA/ModelDesign.xsd",
        e));

    s << *b;
  }

  // Dictionary
  //
  for (ModelDesign::Dictionary_const_iterator
       b (i.Dictionary ().begin ()), n (i.Dictionary ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Dictionary",
        "http://opcfoundation.org/UA/ModelDesign.xsd",
        e));

    s << *b;
  }

  // View
  //
  for (ModelDesign::View_const_iterator
       b (i.View ().begin ()), n (i.View ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "View",
        "http://opcfoundation.org/UA/ModelDesign.xsd",
        e));

    s << *b;
  }

  // TargetNamespace
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "TargetNamespace",
        e));

    a << i.TargetNamespace ();
  }

  // TargetVersion
  //
  if (i.TargetVersion ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "TargetVersion",
        e));

    a << *i.TargetVersion ();
  }

  // TargetPublicationDate
  //
  if (i.TargetPublicationDate ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "TargetPublicationDate",
        e));

    a << *i.TargetPublicationDate ();
  }

  // TargetXmlNamespace
  //
  if (i.TargetXmlNamespace ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "TargetXmlNamespace",
        e));

    a << *i.TargetXmlNamespace ();
  }

  // DefaultLocale
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "DefaultLocale",
        e));

    a << i.DefaultLocale ();
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

