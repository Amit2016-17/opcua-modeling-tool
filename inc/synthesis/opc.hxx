// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef OPC_HXX
#define OPC_HXX

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
class NamespaceTable;
class Namespace;
class NodeDesign;
class TypeDesign;
class ObjectTypeDesign;
class VariableTypeDesign;
class DataTypeDesign;
class ReferenceTypeDesign;
class InstanceDesign;
class ViewDesign;
class ObjectDesign;
class VariableDesign;
class MethodDesign;
class PropertyDesign;
class EncodingDesign;
class DictionaryDesign;
class Reference;
class ListOfReferences;
class Parameter;
class ListOfArguments;
class ListOfFields;
class ListOfEncodings;
class ListOfChildren;
class LocalizedText;
class DefaultValue;
class AccessLevel;
class ValueRank;
class ModellingRule;
class ModelDesign;

#include <memory>    // ::std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

class NamespaceTable: public ::xml_schema::type
{
  public:
  // Namespace
  //
  typedef ::Namespace Namespace_type;
  typedef ::xsd::cxx::tree::sequence< Namespace_type > Namespace_sequence;
  typedef Namespace_sequence::iterator Namespace_iterator;
  typedef Namespace_sequence::const_iterator Namespace_const_iterator;
  typedef ::xsd::cxx::tree::traits< Namespace_type, char > Namespace_traits;

  const Namespace_sequence&
  Namespace () const;

  Namespace_sequence&
  Namespace ();

  void
  Namespace (const Namespace_sequence& s);

  // Constructors.
  //
  NamespaceTable ();

  NamespaceTable (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  NamespaceTable (const NamespaceTable& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual NamespaceTable*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  NamespaceTable&
  operator= (const NamespaceTable& x);

  virtual 
  ~NamespaceTable ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Namespace_sequence Namespace_;
};

class Namespace: public ::xml_schema::string
{
  public:
  // Name
  //
  typedef ::xml_schema::string Name_type;
  typedef ::xsd::cxx::tree::optional< Name_type > Name_optional;
  typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

  const Name_optional&
  Name () const;

  Name_optional&
  Name ();

  void
  Name (const Name_type& x);

  void
  Name (const Name_optional& x);

  void
  Name (::std::auto_ptr< Name_type > p);

  // Prefix
  //
  typedef ::xml_schema::string Prefix_type;
  typedef ::xsd::cxx::tree::optional< Prefix_type > Prefix_optional;
  typedef ::xsd::cxx::tree::traits< Prefix_type, char > Prefix_traits;

  const Prefix_optional&
  Prefix () const;

  Prefix_optional&
  Prefix ();

  void
  Prefix (const Prefix_type& x);

  void
  Prefix (const Prefix_optional& x);

  void
  Prefix (::std::auto_ptr< Prefix_type > p);

  // InternalPrefix
  //
  typedef ::xml_schema::string InternalPrefix_type;
  typedef ::xsd::cxx::tree::optional< InternalPrefix_type > InternalPrefix_optional;
  typedef ::xsd::cxx::tree::traits< InternalPrefix_type, char > InternalPrefix_traits;

  const InternalPrefix_optional&
  InternalPrefix () const;

  InternalPrefix_optional&
  InternalPrefix ();

  void
  InternalPrefix (const InternalPrefix_type& x);

  void
  InternalPrefix (const InternalPrefix_optional& x);

  void
  InternalPrefix (::std::auto_ptr< InternalPrefix_type > p);

  // XmlNamespace
  //
  typedef ::xml_schema::string XmlNamespace_type;
  typedef ::xsd::cxx::tree::optional< XmlNamespace_type > XmlNamespace_optional;
  typedef ::xsd::cxx::tree::traits< XmlNamespace_type, char > XmlNamespace_traits;

  const XmlNamespace_optional&
  XmlNamespace () const;

  XmlNamespace_optional&
  XmlNamespace ();

  void
  XmlNamespace (const XmlNamespace_type& x);

  void
  XmlNamespace (const XmlNamespace_optional& x);

  void
  XmlNamespace (::std::auto_ptr< XmlNamespace_type > p);

  // XmlPrefix
  //
  typedef ::xml_schema::string XmlPrefix_type;
  typedef ::xsd::cxx::tree::optional< XmlPrefix_type > XmlPrefix_optional;
  typedef ::xsd::cxx::tree::traits< XmlPrefix_type, char > XmlPrefix_traits;

  const XmlPrefix_optional&
  XmlPrefix () const;

  XmlPrefix_optional&
  XmlPrefix ();

  void
  XmlPrefix (const XmlPrefix_type& x);

  void
  XmlPrefix (const XmlPrefix_optional& x);

  void
  XmlPrefix (::std::auto_ptr< XmlPrefix_type > p);

  // FilePath
  //
  typedef ::xml_schema::string FilePath_type;
  typedef ::xsd::cxx::tree::optional< FilePath_type > FilePath_optional;
  typedef ::xsd::cxx::tree::traits< FilePath_type, char > FilePath_traits;

  const FilePath_optional&
  FilePath () const;

  FilePath_optional&
  FilePath ();

  void
  FilePath (const FilePath_type& x);

  void
  FilePath (const FilePath_optional& x);

  void
  FilePath (::std::auto_ptr< FilePath_type > p);

  // Constructors.
  //
  Namespace ();

  Namespace (const char*);

  Namespace (const ::std::string&);

  Namespace (const ::xml_schema::string&);

  Namespace (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  Namespace (const Namespace& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual Namespace*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Namespace&
  operator= (const Namespace& x);

  virtual 
  ~Namespace ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Name_optional Name_;
  Prefix_optional Prefix_;
  InternalPrefix_optional InternalPrefix_;
  XmlNamespace_optional XmlNamespace_;
  XmlPrefix_optional XmlPrefix_;
  FilePath_optional FilePath_;
};

class NodeDesign: public ::xml_schema::type
{
  public:
  // BrowseName
  //
  typedef ::xml_schema::string BrowseName_type;
  typedef ::xsd::cxx::tree::optional< BrowseName_type > BrowseName_optional;
  typedef ::xsd::cxx::tree::traits< BrowseName_type, char > BrowseName_traits;

  const BrowseName_optional&
  BrowseName () const;

  BrowseName_optional&
  BrowseName ();

  void
  BrowseName (const BrowseName_type& x);

  void
  BrowseName (const BrowseName_optional& x);

  void
  BrowseName (::std::auto_ptr< BrowseName_type > p);

  // DisplayName
  //
  typedef ::LocalizedText DisplayName_type;
  typedef ::xsd::cxx::tree::optional< DisplayName_type > DisplayName_optional;
  typedef ::xsd::cxx::tree::traits< DisplayName_type, char > DisplayName_traits;

  const DisplayName_optional&
  DisplayName () const;

  DisplayName_optional&
  DisplayName ();

  void
  DisplayName (const DisplayName_type& x);

  void
  DisplayName (const DisplayName_optional& x);

  void
  DisplayName (::std::auto_ptr< DisplayName_type > p);

  // Description
  //
  typedef ::LocalizedText Description_type;
  typedef ::xsd::cxx::tree::optional< Description_type > Description_optional;
  typedef ::xsd::cxx::tree::traits< Description_type, char > Description_traits;

  const Description_optional&
  Description () const;

  Description_optional&
  Description ();

  void
  Description (const Description_type& x);

  void
  Description (const Description_optional& x);

  void
  Description (::std::auto_ptr< Description_type > p);

  // Children
  //
  typedef ::ListOfChildren Children_type;
  typedef ::xsd::cxx::tree::optional< Children_type > Children_optional;
  typedef ::xsd::cxx::tree::traits< Children_type, char > Children_traits;

  const Children_optional&
  Children () const;

  Children_optional&
  Children ();

  void
  Children (const Children_type& x);

  void
  Children (const Children_optional& x);

  void
  Children (::std::auto_ptr< Children_type > p);

  // References
  //
  typedef ::ListOfReferences References_type;
  typedef ::xsd::cxx::tree::optional< References_type > References_optional;
  typedef ::xsd::cxx::tree::traits< References_type, char > References_traits;

  const References_optional&
  References () const;

  References_optional&
  References ();

  void
  References (const References_type& x);

  void
  References (const References_optional& x);

  void
  References (::std::auto_ptr< References_type > p);

  // SymbolicName
  //
  typedef ::xml_schema::qname SymbolicName_type;
  typedef ::xsd::cxx::tree::optional< SymbolicName_type > SymbolicName_optional;
  typedef ::xsd::cxx::tree::traits< SymbolicName_type, char > SymbolicName_traits;

  const SymbolicName_optional&
  SymbolicName () const;

  SymbolicName_optional&
  SymbolicName ();

  void
  SymbolicName (const SymbolicName_type& x);

  void
  SymbolicName (const SymbolicName_optional& x);

  void
  SymbolicName (::std::auto_ptr< SymbolicName_type > p);

  // SymbolicId
  //
  typedef ::xml_schema::qname SymbolicId_type;
  typedef ::xsd::cxx::tree::optional< SymbolicId_type > SymbolicId_optional;
  typedef ::xsd::cxx::tree::traits< SymbolicId_type, char > SymbolicId_traits;

  const SymbolicId_optional&
  SymbolicId () const;

  SymbolicId_optional&
  SymbolicId ();

  void
  SymbolicId (const SymbolicId_type& x);

  void
  SymbolicId (const SymbolicId_optional& x);

  void
  SymbolicId (::std::auto_ptr< SymbolicId_type > p);

  // IsDeclaration
  //
  typedef ::xml_schema::boolean IsDeclaration_type;
  typedef ::xsd::cxx::tree::traits< IsDeclaration_type, char > IsDeclaration_traits;

  const IsDeclaration_type&
  IsDeclaration () const;

  IsDeclaration_type&
  IsDeclaration ();

  void
  IsDeclaration (const IsDeclaration_type& x);

  static IsDeclaration_type
  IsDeclaration_default_value ();

  // NumericId
  //
  typedef ::xml_schema::unsigned_int NumericId_type;
  typedef ::xsd::cxx::tree::optional< NumericId_type > NumericId_optional;
  typedef ::xsd::cxx::tree::traits< NumericId_type, char > NumericId_traits;

  const NumericId_optional&
  NumericId () const;

  NumericId_optional&
  NumericId ();

  void
  NumericId (const NumericId_type& x);

  void
  NumericId (const NumericId_optional& x);

  // StringId
  //
  typedef ::xml_schema::string StringId_type;
  typedef ::xsd::cxx::tree::optional< StringId_type > StringId_optional;
  typedef ::xsd::cxx::tree::traits< StringId_type, char > StringId_traits;

  const StringId_optional&
  StringId () const;

  StringId_optional&
  StringId ();

  void
  StringId (const StringId_type& x);

  void
  StringId (const StringId_optional& x);

  void
  StringId (::std::auto_ptr< StringId_type > p);

  // WriteAccess
  //
  typedef ::xml_schema::unsigned_int WriteAccess_type;
  typedef ::xsd::cxx::tree::traits< WriteAccess_type, char > WriteAccess_traits;

  const WriteAccess_type&
  WriteAccess () const;

  WriteAccess_type&
  WriteAccess ();

  void
  WriteAccess (const WriteAccess_type& x);

  static WriteAccess_type
  WriteAccess_default_value ();

  // PartNo
  //
  typedef ::xml_schema::unsigned_int PartNo_type;
  typedef ::xsd::cxx::tree::traits< PartNo_type, char > PartNo_traits;

  const PartNo_type&
  PartNo () const;

  PartNo_type&
  PartNo ();

  void
  PartNo (const PartNo_type& x);

  static PartNo_type
  PartNo_default_value ();

  // Constructors.
  //
  NodeDesign ();

  NodeDesign (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  NodeDesign (const NodeDesign& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual NodeDesign*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  NodeDesign&
  operator= (const NodeDesign& x);

  virtual 
  ~NodeDesign ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  BrowseName_optional BrowseName_;
  DisplayName_optional DisplayName_;
  Description_optional Description_;
  Children_optional Children_;
  References_optional References_;
  SymbolicName_optional SymbolicName_;
  SymbolicId_optional SymbolicId_;
  ::xsd::cxx::tree::one< IsDeclaration_type > IsDeclaration_;
  NumericId_optional NumericId_;
  StringId_optional StringId_;
  ::xsd::cxx::tree::one< WriteAccess_type > WriteAccess_;
  ::xsd::cxx::tree::one< PartNo_type > PartNo_;
};

class TypeDesign: public ::NodeDesign
{
  public:
  // ClassName
  //
  typedef ::xml_schema::string ClassName_type;
  typedef ::xsd::cxx::tree::optional< ClassName_type > ClassName_optional;
  typedef ::xsd::cxx::tree::traits< ClassName_type, char > ClassName_traits;

  const ClassName_optional&
  ClassName () const;

  ClassName_optional&
  ClassName ();

  void
  ClassName (const ClassName_type& x);

  void
  ClassName (const ClassName_optional& x);

  void
  ClassName (::std::auto_ptr< ClassName_type > p);

  // BaseType
  //
  typedef ::xml_schema::qname BaseType_type;
  typedef ::xsd::cxx::tree::optional< BaseType_type > BaseType_optional;
  typedef ::xsd::cxx::tree::traits< BaseType_type, char > BaseType_traits;

  const BaseType_optional&
  BaseType () const;

  BaseType_optional&
  BaseType ();

  void
  BaseType (const BaseType_type& x);

  void
  BaseType (const BaseType_optional& x);

  void
  BaseType (::std::auto_ptr< BaseType_type > p);

  // IsAbstract
  //
  typedef ::xml_schema::boolean IsAbstract_type;
  typedef ::xsd::cxx::tree::traits< IsAbstract_type, char > IsAbstract_traits;

  const IsAbstract_type&
  IsAbstract () const;

  IsAbstract_type&
  IsAbstract ();

  void
  IsAbstract (const IsAbstract_type& x);

  static IsAbstract_type
  IsAbstract_default_value ();

  // NoClassGeneration
  //
  typedef ::xml_schema::boolean NoClassGeneration_type;
  typedef ::xsd::cxx::tree::traits< NoClassGeneration_type, char > NoClassGeneration_traits;

  const NoClassGeneration_type&
  NoClassGeneration () const;

  NoClassGeneration_type&
  NoClassGeneration ();

  void
  NoClassGeneration (const NoClassGeneration_type& x);

  static NoClassGeneration_type
  NoClassGeneration_default_value ();

  // Constructors.
  //
  TypeDesign ();

  TypeDesign (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  TypeDesign (const TypeDesign& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual TypeDesign*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  TypeDesign&
  operator= (const TypeDesign& x);

  virtual 
  ~TypeDesign ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ClassName_optional ClassName_;
  BaseType_optional BaseType_;
  ::xsd::cxx::tree::one< IsAbstract_type > IsAbstract_;
  ::xsd::cxx::tree::one< NoClassGeneration_type > NoClassGeneration_;
};

class ObjectTypeDesign: public ::TypeDesign
{
  public:
  // SupportsEvents
  //
  typedef ::xml_schema::boolean SupportsEvents_type;
  typedef ::xsd::cxx::tree::optional< SupportsEvents_type > SupportsEvents_optional;
  typedef ::xsd::cxx::tree::traits< SupportsEvents_type, char > SupportsEvents_traits;

  const SupportsEvents_optional&
  SupportsEvents () const;

  SupportsEvents_optional&
  SupportsEvents ();

  void
  SupportsEvents (const SupportsEvents_type& x);

  void
  SupportsEvents (const SupportsEvents_optional& x);

  // Constructors.
  //
  ObjectTypeDesign ();

  ObjectTypeDesign (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  ObjectTypeDesign (const ObjectTypeDesign& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  virtual ObjectTypeDesign*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ObjectTypeDesign&
  operator= (const ObjectTypeDesign& x);

  virtual 
  ~ObjectTypeDesign ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  SupportsEvents_optional SupportsEvents_;
};

class VariableTypeDesign: public ::TypeDesign
{
  public:
  // DefaultValue
  //
  typedef ::DefaultValue DefaultValue_type;
  typedef ::xsd::cxx::tree::optional< DefaultValue_type > DefaultValue_optional;
  typedef ::xsd::cxx::tree::traits< DefaultValue_type, char > DefaultValue_traits;

  const DefaultValue_optional&
  DefaultValue () const;

  DefaultValue_optional&
  DefaultValue ();

  void
  DefaultValue (const DefaultValue_type& x);

  void
  DefaultValue (const DefaultValue_optional& x);

  void
  DefaultValue (::std::auto_ptr< DefaultValue_type > p);

  // DataType
  //
  typedef ::xml_schema::qname DataType_type;
  typedef ::xsd::cxx::tree::optional< DataType_type > DataType_optional;
  typedef ::xsd::cxx::tree::traits< DataType_type, char > DataType_traits;

  const DataType_optional&
  DataType () const;

  DataType_optional&
  DataType ();

  void
  DataType (const DataType_type& x);

  void
  DataType (const DataType_optional& x);

  void
  DataType (::std::auto_ptr< DataType_type > p);

  // ValueRank
  //
  typedef ::ValueRank ValueRank_type;
  typedef ::xsd::cxx::tree::optional< ValueRank_type > ValueRank_optional;
  typedef ::xsd::cxx::tree::traits< ValueRank_type, char > ValueRank_traits;

  const ValueRank_optional&
  ValueRank () const;

  ValueRank_optional&
  ValueRank ();

  void
  ValueRank (const ValueRank_type& x);

  void
  ValueRank (const ValueRank_optional& x);

  void
  ValueRank (::std::auto_ptr< ValueRank_type > p);

  // ArrayDimensions
  //
  typedef ::xml_schema::string ArrayDimensions_type;
  typedef ::xsd::cxx::tree::optional< ArrayDimensions_type > ArrayDimensions_optional;
  typedef ::xsd::cxx::tree::traits< ArrayDimensions_type, char > ArrayDimensions_traits;

  const ArrayDimensions_optional&
  ArrayDimensions () const;

  ArrayDimensions_optional&
  ArrayDimensions ();

  void
  ArrayDimensions (const ArrayDimensions_type& x);

  void
  ArrayDimensions (const ArrayDimensions_optional& x);

  void
  ArrayDimensions (::std::auto_ptr< ArrayDimensions_type > p);

  // AccessLevel
  //
  typedef ::AccessLevel AccessLevel_type;
  typedef ::xsd::cxx::tree::optional< AccessLevel_type > AccessLevel_optional;
  typedef ::xsd::cxx::tree::traits< AccessLevel_type, char > AccessLevel_traits;

  const AccessLevel_optional&
  AccessLevel () const;

  AccessLevel_optional&
  AccessLevel ();

  void
  AccessLevel (const AccessLevel_type& x);

  void
  AccessLevel (const AccessLevel_optional& x);

  void
  AccessLevel (::std::auto_ptr< AccessLevel_type > p);

  // MinimumSamplingInterval
  //
  typedef ::xml_schema::int_ MinimumSamplingInterval_type;
  typedef ::xsd::cxx::tree::optional< MinimumSamplingInterval_type > MinimumSamplingInterval_optional;
  typedef ::xsd::cxx::tree::traits< MinimumSamplingInterval_type, char > MinimumSamplingInterval_traits;

  const MinimumSamplingInterval_optional&
  MinimumSamplingInterval () const;

  MinimumSamplingInterval_optional&
  MinimumSamplingInterval ();

  void
  MinimumSamplingInterval (const MinimumSamplingInterval_type& x);

  void
  MinimumSamplingInterval (const MinimumSamplingInterval_optional& x);

  // Historizing
  //
  typedef ::xml_schema::boolean Historizing_type;
  typedef ::xsd::cxx::tree::optional< Historizing_type > Historizing_optional;
  typedef ::xsd::cxx::tree::traits< Historizing_type, char > Historizing_traits;

  const Historizing_optional&
  Historizing () const;

  Historizing_optional&
  Historizing ();

  void
  Historizing (const Historizing_type& x);

  void
  Historizing (const Historizing_optional& x);

  // ExposesItsChildren
  //
  typedef ::xml_schema::boolean ExposesItsChildren_type;
  typedef ::xsd::cxx::tree::traits< ExposesItsChildren_type, char > ExposesItsChildren_traits;

  const ExposesItsChildren_type&
  ExposesItsChildren () const;

  ExposesItsChildren_type&
  ExposesItsChildren ();

  void
  ExposesItsChildren (const ExposesItsChildren_type& x);

  static ExposesItsChildren_type
  ExposesItsChildren_default_value ();

  // Constructors.
  //
  VariableTypeDesign ();

  VariableTypeDesign (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  VariableTypeDesign (const VariableTypeDesign& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  virtual VariableTypeDesign*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  VariableTypeDesign&
  operator= (const VariableTypeDesign& x);

  virtual 
  ~VariableTypeDesign ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  DefaultValue_optional DefaultValue_;
  DataType_optional DataType_;
  ValueRank_optional ValueRank_;
  ArrayDimensions_optional ArrayDimensions_;
  AccessLevel_optional AccessLevel_;
  MinimumSamplingInterval_optional MinimumSamplingInterval_;
  Historizing_optional Historizing_;
  ::xsd::cxx::tree::one< ExposesItsChildren_type > ExposesItsChildren_;
};

class DataTypeDesign: public ::TypeDesign
{
  public:
  // Fields
  //
  typedef ::ListOfFields Fields_type;
  typedef ::xsd::cxx::tree::optional< Fields_type > Fields_optional;
  typedef ::xsd::cxx::tree::traits< Fields_type, char > Fields_traits;

  const Fields_optional&
  Fields () const;

  Fields_optional&
  Fields ();

  void
  Fields (const Fields_type& x);

  void
  Fields (const Fields_optional& x);

  void
  Fields (::std::auto_ptr< Fields_type > p);

  // Encodings
  //
  typedef ::ListOfEncodings Encodings_type;
  typedef ::xsd::cxx::tree::optional< Encodings_type > Encodings_optional;
  typedef ::xsd::cxx::tree::traits< Encodings_type, char > Encodings_traits;

  const Encodings_optional&
  Encodings () const;

  Encodings_optional&
  Encodings ();

  void
  Encodings (const Encodings_type& x);

  void
  Encodings (const Encodings_optional& x);

  void
  Encodings (::std::auto_ptr< Encodings_type > p);

  // NoArraysAllowed
  //
  typedef ::xml_schema::boolean NoArraysAllowed_type;
  typedef ::xsd::cxx::tree::traits< NoArraysAllowed_type, char > NoArraysAllowed_traits;

  const NoArraysAllowed_type&
  NoArraysAllowed () const;

  NoArraysAllowed_type&
  NoArraysAllowed ();

  void
  NoArraysAllowed (const NoArraysAllowed_type& x);

  static NoArraysAllowed_type
  NoArraysAllowed_default_value ();

  // NotInAddressSpace
  //
  typedef ::xml_schema::boolean NotInAddressSpace_type;
  typedef ::xsd::cxx::tree::traits< NotInAddressSpace_type, char > NotInAddressSpace_traits;

  const NotInAddressSpace_type&
  NotInAddressSpace () const;

  NotInAddressSpace_type&
  NotInAddressSpace ();

  void
  NotInAddressSpace (const NotInAddressSpace_type& x);

  static NotInAddressSpace_type
  NotInAddressSpace_default_value ();

  // Constructors.
  //
  DataTypeDesign ();

  DataTypeDesign (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  DataTypeDesign (const DataTypeDesign& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual DataTypeDesign*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  DataTypeDesign&
  operator= (const DataTypeDesign& x);

  virtual 
  ~DataTypeDesign ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Fields_optional Fields_;
  Encodings_optional Encodings_;
  ::xsd::cxx::tree::one< NoArraysAllowed_type > NoArraysAllowed_;
  ::xsd::cxx::tree::one< NotInAddressSpace_type > NotInAddressSpace_;
};

class ReferenceTypeDesign: public ::TypeDesign
{
  public:
  // InverseName
  //
  typedef ::LocalizedText InverseName_type;
  typedef ::xsd::cxx::tree::optional< InverseName_type > InverseName_optional;
  typedef ::xsd::cxx::tree::traits< InverseName_type, char > InverseName_traits;

  const InverseName_optional&
  InverseName () const;

  InverseName_optional&
  InverseName ();

  void
  InverseName (const InverseName_type& x);

  void
  InverseName (const InverseName_optional& x);

  void
  InverseName (::std::auto_ptr< InverseName_type > p);

  // Symmetric
  //
  typedef ::xml_schema::boolean Symmetric_type;
  typedef ::xsd::cxx::tree::optional< Symmetric_type > Symmetric_optional;
  typedef ::xsd::cxx::tree::traits< Symmetric_type, char > Symmetric_traits;

  const Symmetric_optional&
  Symmetric () const;

  Symmetric_optional&
  Symmetric ();

  void
  Symmetric (const Symmetric_type& x);

  void
  Symmetric (const Symmetric_optional& x);

  // Constructors.
  //
  ReferenceTypeDesign ();

  ReferenceTypeDesign (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  ReferenceTypeDesign (const ReferenceTypeDesign& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  virtual ReferenceTypeDesign*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ReferenceTypeDesign&
  operator= (const ReferenceTypeDesign& x);

  virtual 
  ~ReferenceTypeDesign ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  InverseName_optional InverseName_;
  Symmetric_optional Symmetric_;
};

class InstanceDesign: public ::NodeDesign
{
  public:
  // ReferenceType
  //
  typedef ::xml_schema::qname ReferenceType_type;
  typedef ::xsd::cxx::tree::optional< ReferenceType_type > ReferenceType_optional;
  typedef ::xsd::cxx::tree::traits< ReferenceType_type, char > ReferenceType_traits;

  const ReferenceType_optional&
  ReferenceType () const;

  ReferenceType_optional&
  ReferenceType ();

  void
  ReferenceType (const ReferenceType_type& x);

  void
  ReferenceType (const ReferenceType_optional& x);

  void
  ReferenceType (::std::auto_ptr< ReferenceType_type > p);

  // Declaration
  //
  typedef ::xml_schema::qname Declaration_type;
  typedef ::xsd::cxx::tree::optional< Declaration_type > Declaration_optional;
  typedef ::xsd::cxx::tree::traits< Declaration_type, char > Declaration_traits;

  const Declaration_optional&
  Declaration () const;

  Declaration_optional&
  Declaration ();

  void
  Declaration (const Declaration_type& x);

  void
  Declaration (const Declaration_optional& x);

  void
  Declaration (::std::auto_ptr< Declaration_type > p);

  // TypeDefinition
  //
  typedef ::xml_schema::qname TypeDefinition_type;
  typedef ::xsd::cxx::tree::optional< TypeDefinition_type > TypeDefinition_optional;
  typedef ::xsd::cxx::tree::traits< TypeDefinition_type, char > TypeDefinition_traits;

  const TypeDefinition_optional&
  TypeDefinition () const;

  TypeDefinition_optional&
  TypeDefinition ();

  void
  TypeDefinition (const TypeDefinition_type& x);

  void
  TypeDefinition (const TypeDefinition_optional& x);

  void
  TypeDefinition (::std::auto_ptr< TypeDefinition_type > p);

  // ModellingRule
  //
  typedef ::ModellingRule ModellingRule_type;
  typedef ::xsd::cxx::tree::optional< ModellingRule_type > ModellingRule_optional;
  typedef ::xsd::cxx::tree::traits< ModellingRule_type, char > ModellingRule_traits;

  const ModellingRule_optional&
  ModellingRule () const;

  ModellingRule_optional&
  ModellingRule ();

  void
  ModellingRule (const ModellingRule_type& x);

  void
  ModellingRule (const ModellingRule_optional& x);

  void
  ModellingRule (::std::auto_ptr< ModellingRule_type > p);

  // MinCardinality
  //
  typedef ::xml_schema::unsigned_int MinCardinality_type;
  typedef ::xsd::cxx::tree::traits< MinCardinality_type, char > MinCardinality_traits;

  const MinCardinality_type&
  MinCardinality () const;

  MinCardinality_type&
  MinCardinality ();

  void
  MinCardinality (const MinCardinality_type& x);

  static MinCardinality_type
  MinCardinality_default_value ();

  // MaxCardinality
  //
  typedef ::xml_schema::unsigned_int MaxCardinality_type;
  typedef ::xsd::cxx::tree::traits< MaxCardinality_type, char > MaxCardinality_traits;

  const MaxCardinality_type&
  MaxCardinality () const;

  MaxCardinality_type&
  MaxCardinality ();

  void
  MaxCardinality (const MaxCardinality_type& x);

  static MaxCardinality_type
  MaxCardinality_default_value ();

  // PreserveDefaultAttributes
  //
  typedef ::xml_schema::boolean PreserveDefaultAttributes_type;
  typedef ::xsd::cxx::tree::traits< PreserveDefaultAttributes_type, char > PreserveDefaultAttributes_traits;

  const PreserveDefaultAttributes_type&
  PreserveDefaultAttributes () const;

  PreserveDefaultAttributes_type&
  PreserveDefaultAttributes ();

  void
  PreserveDefaultAttributes (const PreserveDefaultAttributes_type& x);

  static PreserveDefaultAttributes_type
  PreserveDefaultAttributes_default_value ();

  // Constructors.
  //
  InstanceDesign ();

  InstanceDesign (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  InstanceDesign (const InstanceDesign& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual InstanceDesign*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  InstanceDesign&
  operator= (const InstanceDesign& x);

  virtual 
  ~InstanceDesign ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ReferenceType_optional ReferenceType_;
  Declaration_optional Declaration_;
  TypeDefinition_optional TypeDefinition_;
  ModellingRule_optional ModellingRule_;
  ::xsd::cxx::tree::one< MinCardinality_type > MinCardinality_;
  ::xsd::cxx::tree::one< MaxCardinality_type > MaxCardinality_;
  ::xsd::cxx::tree::one< PreserveDefaultAttributes_type > PreserveDefaultAttributes_;
};

class ViewDesign: public ::InstanceDesign
{
  public:
  // SupportsEvents
  //
  typedef ::xml_schema::boolean SupportsEvents_type;
  typedef ::xsd::cxx::tree::traits< SupportsEvents_type, char > SupportsEvents_traits;

  const SupportsEvents_type&
  SupportsEvents () const;

  SupportsEvents_type&
  SupportsEvents ();

  void
  SupportsEvents (const SupportsEvents_type& x);

  static SupportsEvents_type
  SupportsEvents_default_value ();

  // ContainsNoLoops
  //
  typedef ::xml_schema::boolean ContainsNoLoops_type;
  typedef ::xsd::cxx::tree::traits< ContainsNoLoops_type, char > ContainsNoLoops_traits;

  const ContainsNoLoops_type&
  ContainsNoLoops () const;

  ContainsNoLoops_type&
  ContainsNoLoops ();

  void
  ContainsNoLoops (const ContainsNoLoops_type& x);

  static ContainsNoLoops_type
  ContainsNoLoops_default_value ();

  // Constructors.
  //
  ViewDesign ();

  ViewDesign (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  ViewDesign (const ViewDesign& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual ViewDesign*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ViewDesign&
  operator= (const ViewDesign& x);

  virtual 
  ~ViewDesign ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< SupportsEvents_type > SupportsEvents_;
  ::xsd::cxx::tree::one< ContainsNoLoops_type > ContainsNoLoops_;
};

class ObjectDesign: public ::InstanceDesign
{
  public:
  // SupportsEvents
  //
  typedef ::xml_schema::boolean SupportsEvents_type;
  typedef ::xsd::cxx::tree::optional< SupportsEvents_type > SupportsEvents_optional;
  typedef ::xsd::cxx::tree::traits< SupportsEvents_type, char > SupportsEvents_traits;

  const SupportsEvents_optional&
  SupportsEvents () const;

  SupportsEvents_optional&
  SupportsEvents ();

  void
  SupportsEvents (const SupportsEvents_type& x);

  void
  SupportsEvents (const SupportsEvents_optional& x);

  // Constructors.
  //
  ObjectDesign ();

  ObjectDesign (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  ObjectDesign (const ObjectDesign& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual ObjectDesign*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ObjectDesign&
  operator= (const ObjectDesign& x);

  virtual 
  ~ObjectDesign ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  SupportsEvents_optional SupportsEvents_;
};

class VariableDesign: public ::InstanceDesign
{
  public:
  // DefaultValue
  //
  typedef ::DefaultValue DefaultValue_type;
  typedef ::xsd::cxx::tree::optional< DefaultValue_type > DefaultValue_optional;
  typedef ::xsd::cxx::tree::traits< DefaultValue_type, char > DefaultValue_traits;

  const DefaultValue_optional&
  DefaultValue () const;

  DefaultValue_optional&
  DefaultValue ();

  void
  DefaultValue (const DefaultValue_type& x);

  void
  DefaultValue (const DefaultValue_optional& x);

  void
  DefaultValue (::std::auto_ptr< DefaultValue_type > p);

  // DataType
  //
  typedef ::xml_schema::qname DataType_type;
  typedef ::xsd::cxx::tree::optional< DataType_type > DataType_optional;
  typedef ::xsd::cxx::tree::traits< DataType_type, char > DataType_traits;

  const DataType_optional&
  DataType () const;

  DataType_optional&
  DataType ();

  void
  DataType (const DataType_type& x);

  void
  DataType (const DataType_optional& x);

  void
  DataType (::std::auto_ptr< DataType_type > p);

  // ValueRank
  //
  typedef ::ValueRank ValueRank_type;
  typedef ::xsd::cxx::tree::optional< ValueRank_type > ValueRank_optional;
  typedef ::xsd::cxx::tree::traits< ValueRank_type, char > ValueRank_traits;

  const ValueRank_optional&
  ValueRank () const;

  ValueRank_optional&
  ValueRank ();

  void
  ValueRank (const ValueRank_type& x);

  void
  ValueRank (const ValueRank_optional& x);

  void
  ValueRank (::std::auto_ptr< ValueRank_type > p);

  // ArrayDimensions
  //
  typedef ::xml_schema::string ArrayDimensions_type;
  typedef ::xsd::cxx::tree::optional< ArrayDimensions_type > ArrayDimensions_optional;
  typedef ::xsd::cxx::tree::traits< ArrayDimensions_type, char > ArrayDimensions_traits;

  const ArrayDimensions_optional&
  ArrayDimensions () const;

  ArrayDimensions_optional&
  ArrayDimensions ();

  void
  ArrayDimensions (const ArrayDimensions_type& x);

  void
  ArrayDimensions (const ArrayDimensions_optional& x);

  void
  ArrayDimensions (::std::auto_ptr< ArrayDimensions_type > p);

  // AccessLevel
  //
  typedef ::AccessLevel AccessLevel_type;
  typedef ::xsd::cxx::tree::optional< AccessLevel_type > AccessLevel_optional;
  typedef ::xsd::cxx::tree::traits< AccessLevel_type, char > AccessLevel_traits;

  const AccessLevel_optional&
  AccessLevel () const;

  AccessLevel_optional&
  AccessLevel ();

  void
  AccessLevel (const AccessLevel_type& x);

  void
  AccessLevel (const AccessLevel_optional& x);

  void
  AccessLevel (::std::auto_ptr< AccessLevel_type > p);

  // MinimumSamplingInterval
  //
  typedef ::xml_schema::int_ MinimumSamplingInterval_type;
  typedef ::xsd::cxx::tree::optional< MinimumSamplingInterval_type > MinimumSamplingInterval_optional;
  typedef ::xsd::cxx::tree::traits< MinimumSamplingInterval_type, char > MinimumSamplingInterval_traits;

  const MinimumSamplingInterval_optional&
  MinimumSamplingInterval () const;

  MinimumSamplingInterval_optional&
  MinimumSamplingInterval ();

  void
  MinimumSamplingInterval (const MinimumSamplingInterval_type& x);

  void
  MinimumSamplingInterval (const MinimumSamplingInterval_optional& x);

  // Historizing
  //
  typedef ::xml_schema::boolean Historizing_type;
  typedef ::xsd::cxx::tree::optional< Historizing_type > Historizing_optional;
  typedef ::xsd::cxx::tree::traits< Historizing_type, char > Historizing_traits;

  const Historizing_optional&
  Historizing () const;

  Historizing_optional&
  Historizing ();

  void
  Historizing (const Historizing_type& x);

  void
  Historizing (const Historizing_optional& x);

  // Constructors.
  //
  VariableDesign ();

  VariableDesign (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  VariableDesign (const VariableDesign& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual VariableDesign*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  VariableDesign&
  operator= (const VariableDesign& x);

  virtual 
  ~VariableDesign ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  DefaultValue_optional DefaultValue_;
  DataType_optional DataType_;
  ValueRank_optional ValueRank_;
  ArrayDimensions_optional ArrayDimensions_;
  AccessLevel_optional AccessLevel_;
  MinimumSamplingInterval_optional MinimumSamplingInterval_;
  Historizing_optional Historizing_;
};

class MethodDesign: public ::InstanceDesign
{
  public:
  // InputArguments
  //
  typedef ::ListOfArguments InputArguments_type;
  typedef ::xsd::cxx::tree::optional< InputArguments_type > InputArguments_optional;
  typedef ::xsd::cxx::tree::traits< InputArguments_type, char > InputArguments_traits;

  const InputArguments_optional&
  InputArguments () const;

  InputArguments_optional&
  InputArguments ();

  void
  InputArguments (const InputArguments_type& x);

  void
  InputArguments (const InputArguments_optional& x);

  void
  InputArguments (::std::auto_ptr< InputArguments_type > p);

  // OutputArguments
  //
  typedef ::ListOfArguments OutputArguments_type;
  typedef ::xsd::cxx::tree::optional< OutputArguments_type > OutputArguments_optional;
  typedef ::xsd::cxx::tree::traits< OutputArguments_type, char > OutputArguments_traits;

  const OutputArguments_optional&
  OutputArguments () const;

  OutputArguments_optional&
  OutputArguments ();

  void
  OutputArguments (const OutputArguments_type& x);

  void
  OutputArguments (const OutputArguments_optional& x);

  void
  OutputArguments (::std::auto_ptr< OutputArguments_type > p);

  // NonExecutable
  //
  typedef ::xml_schema::boolean NonExecutable_type;
  typedef ::xsd::cxx::tree::optional< NonExecutable_type > NonExecutable_optional;
  typedef ::xsd::cxx::tree::traits< NonExecutable_type, char > NonExecutable_traits;

  const NonExecutable_optional&
  NonExecutable () const;

  NonExecutable_optional&
  NonExecutable ();

  void
  NonExecutable (const NonExecutable_type& x);

  void
  NonExecutable (const NonExecutable_optional& x);

  // Constructors.
  //
  MethodDesign ();

  MethodDesign (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  MethodDesign (const MethodDesign& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual MethodDesign*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  MethodDesign&
  operator= (const MethodDesign& x);

  virtual 
  ~MethodDesign ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  InputArguments_optional InputArguments_;
  OutputArguments_optional OutputArguments_;
  NonExecutable_optional NonExecutable_;
};

class PropertyDesign: public ::VariableDesign
{
  public:
  // Constructors.
  //
  PropertyDesign ();

  PropertyDesign (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  PropertyDesign (const PropertyDesign& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual PropertyDesign*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~PropertyDesign ();
};

class EncodingDesign: public ::ObjectDesign
{
  public:
  // Constructors.
  //
  EncodingDesign ();

  EncodingDesign (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  EncodingDesign (const EncodingDesign& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual EncodingDesign*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~EncodingDesign ();
};

class DictionaryDesign: public ::VariableDesign
{
  public:
  // EncodingName
  //
  typedef ::xml_schema::qname EncodingName_type;
  typedef ::xsd::cxx::tree::traits< EncodingName_type, char > EncodingName_traits;

  const EncodingName_type&
  EncodingName () const;

  EncodingName_type&
  EncodingName ();

  void
  EncodingName (const EncodingName_type& x);

  void
  EncodingName (::std::auto_ptr< EncodingName_type > p);

  // Constructors.
  //
  DictionaryDesign (const EncodingName_type&);

  DictionaryDesign (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  DictionaryDesign (const DictionaryDesign& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  virtual DictionaryDesign*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  DictionaryDesign&
  operator= (const DictionaryDesign& x);

  virtual 
  ~DictionaryDesign ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< EncodingName_type > EncodingName_;
};

class Reference: public ::xml_schema::type
{
  public:
  // ReferenceType
  //
  typedef ::xml_schema::qname ReferenceType_type;
  typedef ::xsd::cxx::tree::traits< ReferenceType_type, char > ReferenceType_traits;

  const ReferenceType_type&
  ReferenceType () const;

  ReferenceType_type&
  ReferenceType ();

  void
  ReferenceType (const ReferenceType_type& x);

  void
  ReferenceType (::std::auto_ptr< ReferenceType_type > p);

  // TargetId
  //
  typedef ::xml_schema::qname TargetId_type;
  typedef ::xsd::cxx::tree::traits< TargetId_type, char > TargetId_traits;

  const TargetId_type&
  TargetId () const;

  TargetId_type&
  TargetId ();

  void
  TargetId (const TargetId_type& x);

  void
  TargetId (::std::auto_ptr< TargetId_type > p);

  // IsInverse
  //
  typedef ::xml_schema::boolean IsInverse_type;
  typedef ::xsd::cxx::tree::traits< IsInverse_type, char > IsInverse_traits;

  const IsInverse_type&
  IsInverse () const;

  IsInverse_type&
  IsInverse ();

  void
  IsInverse (const IsInverse_type& x);

  static IsInverse_type
  IsInverse_default_value ();

  // IsOneWay
  //
  typedef ::xml_schema::boolean IsOneWay_type;
  typedef ::xsd::cxx::tree::traits< IsOneWay_type, char > IsOneWay_traits;

  const IsOneWay_type&
  IsOneWay () const;

  IsOneWay_type&
  IsOneWay ();

  void
  IsOneWay (const IsOneWay_type& x);

  static IsOneWay_type
  IsOneWay_default_value ();

  // Constructors.
  //
  Reference (const ReferenceType_type&,
             const TargetId_type&);

  Reference (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  Reference (const Reference& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual Reference*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Reference&
  operator= (const Reference& x);

  virtual 
  ~Reference ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< ReferenceType_type > ReferenceType_;
  ::xsd::cxx::tree::one< TargetId_type > TargetId_;
  ::xsd::cxx::tree::one< IsInverse_type > IsInverse_;
  ::xsd::cxx::tree::one< IsOneWay_type > IsOneWay_;
};

class ListOfReferences: public ::xml_schema::type
{
  public:
  // Reference
  //
  typedef ::Reference Reference_type;
  typedef ::xsd::cxx::tree::sequence< Reference_type > Reference_sequence;
  typedef Reference_sequence::iterator Reference_iterator;
  typedef Reference_sequence::const_iterator Reference_const_iterator;
  typedef ::xsd::cxx::tree::traits< Reference_type, char > Reference_traits;

  const Reference_sequence&
  Reference () const;

  Reference_sequence&
  Reference ();

  void
  Reference (const Reference_sequence& s);

  // Constructors.
  //
  ListOfReferences ();

  ListOfReferences (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  ListOfReferences (const ListOfReferences& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  virtual ListOfReferences*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ListOfReferences&
  operator= (const ListOfReferences& x);

  virtual 
  ~ListOfReferences ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Reference_sequence Reference_;
};

class Parameter: public ::xml_schema::type
{
  public:
  // Description
  //
  typedef ::LocalizedText Description_type;
  typedef ::xsd::cxx::tree::optional< Description_type > Description_optional;
  typedef ::xsd::cxx::tree::traits< Description_type, char > Description_traits;

  const Description_optional&
  Description () const;

  Description_optional&
  Description ();

  void
  Description (const Description_type& x);

  void
  Description (const Description_optional& x);

  void
  Description (::std::auto_ptr< Description_type > p);

  // Name
  //
  typedef ::xml_schema::string Name_type;
  typedef ::xsd::cxx::tree::optional< Name_type > Name_optional;
  typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

  const Name_optional&
  Name () const;

  Name_optional&
  Name ();

  void
  Name (const Name_type& x);

  void
  Name (const Name_optional& x);

  void
  Name (::std::auto_ptr< Name_type > p);

  // Identifier
  //
  typedef ::xml_schema::int_ Identifier_type;
  typedef ::xsd::cxx::tree::optional< Identifier_type > Identifier_optional;
  typedef ::xsd::cxx::tree::traits< Identifier_type, char > Identifier_traits;

  const Identifier_optional&
  Identifier () const;

  Identifier_optional&
  Identifier ();

  void
  Identifier (const Identifier_type& x);

  void
  Identifier (const Identifier_optional& x);

  // DataType
  //
  typedef ::xml_schema::qname DataType_type;
  typedef ::xsd::cxx::tree::optional< DataType_type > DataType_optional;
  typedef ::xsd::cxx::tree::traits< DataType_type, char > DataType_traits;

  const DataType_optional&
  DataType () const;

  DataType_optional&
  DataType ();

  void
  DataType (const DataType_type& x);

  void
  DataType (const DataType_optional& x);

  void
  DataType (::std::auto_ptr< DataType_type > p);

  // ValueRank
  //
  typedef ::ValueRank ValueRank_type;
  typedef ::xsd::cxx::tree::traits< ValueRank_type, char > ValueRank_traits;

  const ValueRank_type&
  ValueRank () const;

  ValueRank_type&
  ValueRank ();

  void
  ValueRank (const ValueRank_type& x);

  void
  ValueRank (::std::auto_ptr< ValueRank_type > p);

  static const ValueRank_type&
  ValueRank_default_value ();

  // ArrayDimensions
  //
  typedef ::xml_schema::string ArrayDimensions_type;
  typedef ::xsd::cxx::tree::optional< ArrayDimensions_type > ArrayDimensions_optional;
  typedef ::xsd::cxx::tree::traits< ArrayDimensions_type, char > ArrayDimensions_traits;

  const ArrayDimensions_optional&
  ArrayDimensions () const;

  ArrayDimensions_optional&
  ArrayDimensions ();

  void
  ArrayDimensions (const ArrayDimensions_type& x);

  void
  ArrayDimensions (const ArrayDimensions_optional& x);

  void
  ArrayDimensions (::std::auto_ptr< ArrayDimensions_type > p);

  // Constructors.
  //
  Parameter ();

  Parameter (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  Parameter (const Parameter& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual Parameter*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Parameter&
  operator= (const Parameter& x);

  virtual 
  ~Parameter ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Description_optional Description_;
  Name_optional Name_;
  Identifier_optional Identifier_;
  DataType_optional DataType_;
  ::xsd::cxx::tree::one< ValueRank_type > ValueRank_;
  static const ValueRank_type ValueRank_default_value_;
  ArrayDimensions_optional ArrayDimensions_;
};

class ListOfArguments: public ::xml_schema::type
{
  public:
  // Argument
  //
  typedef ::Parameter Argument_type;
  typedef ::xsd::cxx::tree::sequence< Argument_type > Argument_sequence;
  typedef Argument_sequence::iterator Argument_iterator;
  typedef Argument_sequence::const_iterator Argument_const_iterator;
  typedef ::xsd::cxx::tree::traits< Argument_type, char > Argument_traits;

  const Argument_sequence&
  Argument () const;

  Argument_sequence&
  Argument ();

  void
  Argument (const Argument_sequence& s);

  // Constructors.
  //
  ListOfArguments ();

  ListOfArguments (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  ListOfArguments (const ListOfArguments& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  virtual ListOfArguments*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ListOfArguments&
  operator= (const ListOfArguments& x);

  virtual 
  ~ListOfArguments ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Argument_sequence Argument_;
};

class ListOfFields: public ::xml_schema::type
{
  public:
  // Field
  //
  typedef ::Parameter Field_type;
  typedef ::xsd::cxx::tree::sequence< Field_type > Field_sequence;
  typedef Field_sequence::iterator Field_iterator;
  typedef Field_sequence::const_iterator Field_const_iterator;
  typedef ::xsd::cxx::tree::traits< Field_type, char > Field_traits;

  const Field_sequence&
  Field () const;

  Field_sequence&
  Field ();

  void
  Field (const Field_sequence& s);

  // Constructors.
  //
  ListOfFields ();

  ListOfFields (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  ListOfFields (const ListOfFields& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual ListOfFields*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ListOfFields&
  operator= (const ListOfFields& x);

  virtual 
  ~ListOfFields ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Field_sequence Field_;
};

class ListOfEncodings: public ::xml_schema::type
{
  public:
  // Encoding
  //
  typedef ::EncodingDesign Encoding_type;
  typedef ::xsd::cxx::tree::sequence< Encoding_type > Encoding_sequence;
  typedef Encoding_sequence::iterator Encoding_iterator;
  typedef Encoding_sequence::const_iterator Encoding_const_iterator;
  typedef ::xsd::cxx::tree::traits< Encoding_type, char > Encoding_traits;

  const Encoding_sequence&
  Encoding () const;

  Encoding_sequence&
  Encoding ();

  void
  Encoding (const Encoding_sequence& s);

  // Constructors.
  //
  ListOfEncodings ();

  ListOfEncodings (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  ListOfEncodings (const ListOfEncodings& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  virtual ListOfEncodings*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ListOfEncodings&
  operator= (const ListOfEncodings& x);

  virtual 
  ~ListOfEncodings ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Encoding_sequence Encoding_;
};

class ListOfChildren: public ::xml_schema::type
{
  public:
  // Object
  //
  typedef ::ObjectDesign Object_type;
  typedef ::xsd::cxx::tree::sequence< Object_type > Object_sequence;
  typedef Object_sequence::iterator Object_iterator;
  typedef Object_sequence::const_iterator Object_const_iterator;
  typedef ::xsd::cxx::tree::traits< Object_type, char > Object_traits;

  const Object_sequence&
  Object () const;

  Object_sequence&
  Object ();

  void
  Object (const Object_sequence& s);

  // Variable
  //
  typedef ::VariableDesign Variable_type;
  typedef ::xsd::cxx::tree::sequence< Variable_type > Variable_sequence;
  typedef Variable_sequence::iterator Variable_iterator;
  typedef Variable_sequence::const_iterator Variable_const_iterator;
  typedef ::xsd::cxx::tree::traits< Variable_type, char > Variable_traits;

  const Variable_sequence&
  Variable () const;

  Variable_sequence&
  Variable ();

  void
  Variable (const Variable_sequence& s);

  // Property
  //
  typedef ::PropertyDesign Property_type;
  typedef ::xsd::cxx::tree::sequence< Property_type > Property_sequence;
  typedef Property_sequence::iterator Property_iterator;
  typedef Property_sequence::const_iterator Property_const_iterator;
  typedef ::xsd::cxx::tree::traits< Property_type, char > Property_traits;

  const Property_sequence&
  Property () const;

  Property_sequence&
  Property ();

  void
  Property (const Property_sequence& s);

  // Method
  //
  typedef ::MethodDesign Method_type;
  typedef ::xsd::cxx::tree::sequence< Method_type > Method_sequence;
  typedef Method_sequence::iterator Method_iterator;
  typedef Method_sequence::const_iterator Method_const_iterator;
  typedef ::xsd::cxx::tree::traits< Method_type, char > Method_traits;

  const Method_sequence&
  Method () const;

  Method_sequence&
  Method ();

  void
  Method (const Method_sequence& s);

  // Constructors.
  //
  ListOfChildren ();

  ListOfChildren (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  ListOfChildren (const ListOfChildren& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual ListOfChildren*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ListOfChildren&
  operator= (const ListOfChildren& x);

  virtual 
  ~ListOfChildren ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Object_sequence Object_;
  Variable_sequence Variable_;
  Property_sequence Property_;
  Method_sequence Method_;
};

class LocalizedText: public ::xml_schema::string
{
  public:
  // Key
  //
  typedef ::xml_schema::string Key_type;
  typedef ::xsd::cxx::tree::traits< Key_type, char > Key_traits;

  const Key_type&
  Key () const;

  Key_type&
  Key ();

  void
  Key (const Key_type& x);

  void
  Key (::std::auto_ptr< Key_type > p);

  static const Key_type&
  Key_default_value ();

  // Constructors.
  //
  LocalizedText ();

  LocalizedText (const char*);

  LocalizedText (const ::std::string&);

  LocalizedText (const ::xml_schema::string&);

  LocalizedText (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  LocalizedText (const LocalizedText& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual LocalizedText*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  LocalizedText&
  operator= (const LocalizedText& x);

  virtual 
  ~LocalizedText ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Key_type > Key_;
  static const Key_type Key_default_value_;
};

class DefaultValue: public ::xml_schema::type
{
  public:
  // Constructors.
  //
  DefaultValue ();

  DefaultValue (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  DefaultValue (const DefaultValue& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual DefaultValue*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~DefaultValue ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
};

class AccessLevel: public ::xml_schema::string
{
  public:
  enum value
  {
    None,
    Read,
    Write,
    ReadWrite
  };

  AccessLevel (value v);

  AccessLevel (const char* v);

  AccessLevel (const ::std::string& v);

  AccessLevel (const ::xml_schema::string& v);

  AccessLevel (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  AccessLevel (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  AccessLevel (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  AccessLevel (const AccessLevel& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual AccessLevel*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  AccessLevel&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_AccessLevel_convert ();
  }

  protected:
  value
  _xsd_AccessLevel_convert () const;

  public:
  static const char* const _xsd_AccessLevel_literals_[4];
  static const value _xsd_AccessLevel_indexes_[4];
};

class ValueRank: public ::xml_schema::string
{
  public:
  enum value
  {
    Scalar,
    Array,
    ScalarOrArray,
    OneOrMoreDimensions
  };

  ValueRank (value v);

  ValueRank (const char* v);

  ValueRank (const ::std::string& v);

  ValueRank (const ::xml_schema::string& v);

  ValueRank (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  ValueRank (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  ValueRank (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  ValueRank (const ValueRank& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual ValueRank*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ValueRank&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_ValueRank_convert ();
  }

  protected:
  value
  _xsd_ValueRank_convert () const;

  public:
  static const char* const _xsd_ValueRank_literals_[4];
  static const value _xsd_ValueRank_indexes_[4];
};

class ModellingRule: public ::xml_schema::string
{
  public:
  enum value
  {
    None,
    Mandatory,
    Optional,
    ExposesItsArray,
    CardinalityRestriction,
    MandatoryShared,
    OptionalPlaceholder,
    MandatoryPlaceholder
  };

  ModellingRule (value v);

  ModellingRule (const char* v);

  ModellingRule (const ::std::string& v);

  ModellingRule (const ::xml_schema::string& v);

  ModellingRule (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  ModellingRule (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  ModellingRule (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  ModellingRule (const ModellingRule& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual ModellingRule*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ModellingRule&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_ModellingRule_convert ();
  }

  protected:
  value
  _xsd_ModellingRule_convert () const;

  public:
  static const char* const _xsd_ModellingRule_literals_[8];
  static const value _xsd_ModellingRule_indexes_[8];
};

class ModelDesign: public ::xml_schema::type
{
  public:
  // Namespaces
  //
  typedef ::NamespaceTable Namespaces_type;
  typedef ::xsd::cxx::tree::optional< Namespaces_type > Namespaces_optional;
  typedef ::xsd::cxx::tree::traits< Namespaces_type, char > Namespaces_traits;

  const Namespaces_optional&
  Namespaces () const;

  Namespaces_optional&
  Namespaces ();

  void
  Namespaces (const Namespaces_type& x);

  void
  Namespaces (const Namespaces_optional& x);

  void
  Namespaces (::std::auto_ptr< Namespaces_type > p);

  // VariableType
  //
  typedef ::VariableTypeDesign VariableType_type;
  typedef ::xsd::cxx::tree::sequence< VariableType_type > VariableType_sequence;
  typedef VariableType_sequence::iterator VariableType_iterator;
  typedef VariableType_sequence::const_iterator VariableType_const_iterator;
  typedef ::xsd::cxx::tree::traits< VariableType_type, char > VariableType_traits;

  const VariableType_sequence&
  VariableType () const;

  VariableType_sequence&
  VariableType ();

  void
  VariableType (const VariableType_sequence& s);

  // ReferenceType
  //
  typedef ::ReferenceTypeDesign ReferenceType_type;
  typedef ::xsd::cxx::tree::sequence< ReferenceType_type > ReferenceType_sequence;
  typedef ReferenceType_sequence::iterator ReferenceType_iterator;
  typedef ReferenceType_sequence::const_iterator ReferenceType_const_iterator;
  typedef ::xsd::cxx::tree::traits< ReferenceType_type, char > ReferenceType_traits;

  const ReferenceType_sequence&
  ReferenceType () const;

  ReferenceType_sequence&
  ReferenceType ();

  void
  ReferenceType (const ReferenceType_sequence& s);

  // DataType
  //
  typedef ::DataTypeDesign DataType_type;
  typedef ::xsd::cxx::tree::sequence< DataType_type > DataType_sequence;
  typedef DataType_sequence::iterator DataType_iterator;
  typedef DataType_sequence::const_iterator DataType_const_iterator;
  typedef ::xsd::cxx::tree::traits< DataType_type, char > DataType_traits;

  const DataType_sequence&
  DataType () const;

  DataType_sequence&
  DataType ();

  void
  DataType (const DataType_sequence& s);

  // Method
  //
  typedef ::MethodDesign Method_type;
  typedef ::xsd::cxx::tree::sequence< Method_type > Method_sequence;
  typedef Method_sequence::iterator Method_iterator;
  typedef Method_sequence::const_iterator Method_const_iterator;
  typedef ::xsd::cxx::tree::traits< Method_type, char > Method_traits;

  const Method_sequence&
  Method () const;

  Method_sequence&
  Method ();

  void
  Method (const Method_sequence& s);

  // ObjectType
  //
  typedef ::ObjectTypeDesign ObjectType_type;
  typedef ::xsd::cxx::tree::sequence< ObjectType_type > ObjectType_sequence;
  typedef ObjectType_sequence::iterator ObjectType_iterator;
  typedef ObjectType_sequence::const_iterator ObjectType_const_iterator;
  typedef ::xsd::cxx::tree::traits< ObjectType_type, char > ObjectType_traits;

  const ObjectType_sequence&
  ObjectType () const;

  ObjectType_sequence&
  ObjectType ();

  void
  ObjectType (const ObjectType_sequence& s);

  // Object
  //
  typedef ::ObjectDesign Object_type;
  typedef ::xsd::cxx::tree::sequence< Object_type > Object_sequence;
  typedef Object_sequence::iterator Object_iterator;
  typedef Object_sequence::const_iterator Object_const_iterator;
  typedef ::xsd::cxx::tree::traits< Object_type, char > Object_traits;

  const Object_sequence&
  Object () const;

  Object_sequence&
  Object ();

  void
  Object (const Object_sequence& s);

  // Variable
  //
  typedef ::VariableDesign Variable_type;
  typedef ::xsd::cxx::tree::sequence< Variable_type > Variable_sequence;
  typedef Variable_sequence::iterator Variable_iterator;
  typedef Variable_sequence::const_iterator Variable_const_iterator;
  typedef ::xsd::cxx::tree::traits< Variable_type, char > Variable_traits;

  const Variable_sequence&
  Variable () const;

  Variable_sequence&
  Variable ();

  void
  Variable (const Variable_sequence& s);

  // Property
  //
  typedef ::PropertyDesign Property_type;
  typedef ::xsd::cxx::tree::sequence< Property_type > Property_sequence;
  typedef Property_sequence::iterator Property_iterator;
  typedef Property_sequence::const_iterator Property_const_iterator;
  typedef ::xsd::cxx::tree::traits< Property_type, char > Property_traits;

  const Property_sequence&
  Property () const;

  Property_sequence&
  Property ();

  void
  Property (const Property_sequence& s);

  // Dictionary
  //
  typedef ::DictionaryDesign Dictionary_type;
  typedef ::xsd::cxx::tree::sequence< Dictionary_type > Dictionary_sequence;
  typedef Dictionary_sequence::iterator Dictionary_iterator;
  typedef Dictionary_sequence::const_iterator Dictionary_const_iterator;
  typedef ::xsd::cxx::tree::traits< Dictionary_type, char > Dictionary_traits;

  const Dictionary_sequence&
  Dictionary () const;

  Dictionary_sequence&
  Dictionary ();

  void
  Dictionary (const Dictionary_sequence& s);

  // View
  //
  typedef ::ViewDesign View_type;
  typedef ::xsd::cxx::tree::sequence< View_type > View_sequence;
  typedef View_sequence::iterator View_iterator;
  typedef View_sequence::const_iterator View_const_iterator;
  typedef ::xsd::cxx::tree::traits< View_type, char > View_traits;

  const View_sequence&
  View () const;

  View_sequence&
  View ();

  void
  View (const View_sequence& s);

  // TargetNamespace
  //
  typedef ::xml_schema::string TargetNamespace_type;
  typedef ::xsd::cxx::tree::traits< TargetNamespace_type, char > TargetNamespace_traits;

  const TargetNamespace_type&
  TargetNamespace () const;

  TargetNamespace_type&
  TargetNamespace ();

  void
  TargetNamespace (const TargetNamespace_type& x);

  void
  TargetNamespace (::std::auto_ptr< TargetNamespace_type > p);

  // TargetVersion
  //
  typedef ::xml_schema::string TargetVersion_type;
  typedef ::xsd::cxx::tree::optional< TargetVersion_type > TargetVersion_optional;
  typedef ::xsd::cxx::tree::traits< TargetVersion_type, char > TargetVersion_traits;

  const TargetVersion_optional&
  TargetVersion () const;

  TargetVersion_optional&
  TargetVersion ();

  void
  TargetVersion (const TargetVersion_type& x);

  void
  TargetVersion (const TargetVersion_optional& x);

  void
  TargetVersion (::std::auto_ptr< TargetVersion_type > p);

  // TargetPublicationDate
  //
  typedef ::xml_schema::date_time TargetPublicationDate_type;
  typedef ::xsd::cxx::tree::optional< TargetPublicationDate_type > TargetPublicationDate_optional;
  typedef ::xsd::cxx::tree::traits< TargetPublicationDate_type, char > TargetPublicationDate_traits;

  const TargetPublicationDate_optional&
  TargetPublicationDate () const;

  TargetPublicationDate_optional&
  TargetPublicationDate ();

  void
  TargetPublicationDate (const TargetPublicationDate_type& x);

  void
  TargetPublicationDate (const TargetPublicationDate_optional& x);

  void
  TargetPublicationDate (::std::auto_ptr< TargetPublicationDate_type > p);

  // TargetXmlNamespace
  //
  typedef ::xml_schema::string TargetXmlNamespace_type;
  typedef ::xsd::cxx::tree::optional< TargetXmlNamespace_type > TargetXmlNamespace_optional;
  typedef ::xsd::cxx::tree::traits< TargetXmlNamespace_type, char > TargetXmlNamespace_traits;

  const TargetXmlNamespace_optional&
  TargetXmlNamespace () const;

  TargetXmlNamespace_optional&
  TargetXmlNamespace ();

  void
  TargetXmlNamespace (const TargetXmlNamespace_type& x);

  void
  TargetXmlNamespace (const TargetXmlNamespace_optional& x);

  void
  TargetXmlNamespace (::std::auto_ptr< TargetXmlNamespace_type > p);

  // DefaultLocale
  //
  typedef ::xml_schema::string DefaultLocale_type;
  typedef ::xsd::cxx::tree::traits< DefaultLocale_type, char > DefaultLocale_traits;

  const DefaultLocale_type&
  DefaultLocale () const;

  DefaultLocale_type&
  DefaultLocale ();

  void
  DefaultLocale (const DefaultLocale_type& x);

  void
  DefaultLocale (::std::auto_ptr< DefaultLocale_type > p);

  static const DefaultLocale_type&
  DefaultLocale_default_value ();

  // Constructors.
  //
  ModelDesign (const TargetNamespace_type&);

  ModelDesign (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  ModelDesign (const ModelDesign& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual ModelDesign*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ModelDesign&
  operator= (const ModelDesign& x);

  virtual 
  ~ModelDesign ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Namespaces_optional Namespaces_;
  VariableType_sequence VariableType_;
  ReferenceType_sequence ReferenceType_;
  DataType_sequence DataType_;
  Method_sequence Method_;
  ObjectType_sequence ObjectType_;
  Object_sequence Object_;
  Variable_sequence Variable_;
  Property_sequence Property_;
  Dictionary_sequence Dictionary_;
  View_sequence View_;
  ::xsd::cxx::tree::one< TargetNamespace_type > TargetNamespace_;
  TargetVersion_optional TargetVersion_;
  TargetPublicationDate_optional TargetPublicationDate_;
  TargetXmlNamespace_optional TargetXmlNamespace_;
  ::xsd::cxx::tree::one< DefaultLocale_type > DefaultLocale_;
  static const DefaultLocale_type DefaultLocale_default_value_;
};

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

// Parse a URI or a local file.
//

::std::auto_ptr< ::ModelDesign >
ModelDesign_ (const ::std::string& uri,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::ModelDesign >
ModelDesign_ (const ::std::string& uri,
              ::xml_schema::error_handler& eh,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::ModelDesign >
ModelDesign_ (const ::std::string& uri,
              ::xercesc::DOMErrorHandler& eh,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse std::istream.
//

::std::auto_ptr< ::ModelDesign >
ModelDesign_ (::std::istream& is,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::ModelDesign >
ModelDesign_ (::std::istream& is,
              ::xml_schema::error_handler& eh,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::ModelDesign >
ModelDesign_ (::std::istream& is,
              ::xercesc::DOMErrorHandler& eh,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::ModelDesign >
ModelDesign_ (::std::istream& is,
              const ::std::string& id,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::ModelDesign >
ModelDesign_ (::std::istream& is,
              const ::std::string& id,
              ::xml_schema::error_handler& eh,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::ModelDesign >
ModelDesign_ (::std::istream& is,
              const ::std::string& id,
              ::xercesc::DOMErrorHandler& eh,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::InputSource.
//

::std::auto_ptr< ::ModelDesign >
ModelDesign_ (::xercesc::InputSource& is,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::ModelDesign >
ModelDesign_ (::xercesc::InputSource& is,
              ::xml_schema::error_handler& eh,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::ModelDesign >
ModelDesign_ (::xercesc::InputSource& is,
              ::xercesc::DOMErrorHandler& eh,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::DOMDocument.
//

::std::auto_ptr< ::ModelDesign >
ModelDesign_ (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::ModelDesign >
ModelDesign_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

// Serialize to std::ostream.
//

void
ModelDesign_ (::std::ostream& os,
              const ::ModelDesign& x, 
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::string& e = "UTF-8",
              ::xml_schema::flags f = 0);

void
ModelDesign_ (::std::ostream& os,
              const ::ModelDesign& x, 
              ::xml_schema::error_handler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::string& e = "UTF-8",
              ::xml_schema::flags f = 0);

void
ModelDesign_ (::std::ostream& os,
              const ::ModelDesign& x, 
              ::xercesc::DOMErrorHandler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::string& e = "UTF-8",
              ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
ModelDesign_ (::xercesc::XMLFormatTarget& ft,
              const ::ModelDesign& x, 
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::string& e = "UTF-8",
              ::xml_schema::flags f = 0);

void
ModelDesign_ (::xercesc::XMLFormatTarget& ft,
              const ::ModelDesign& x, 
              ::xml_schema::error_handler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::string& e = "UTF-8",
              ::xml_schema::flags f = 0);

void
ModelDesign_ (::xercesc::XMLFormatTarget& ft,
              const ::ModelDesign& x, 
              ::xercesc::DOMErrorHandler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::string& e = "UTF-8",
              ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
ModelDesign_ (::xercesc::DOMDocument& d,
              const ::ModelDesign& x,
              ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
ModelDesign_ (const ::ModelDesign& x, 
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              ::xml_schema::flags f = 0);

void
operator<< (::xercesc::DOMElement&, const NamespaceTable&);

void
operator<< (::xercesc::DOMElement&, const Namespace&);

void
operator<< (::xercesc::DOMElement&, const NodeDesign&);

void
operator<< (::xercesc::DOMElement&, const TypeDesign&);

void
operator<< (::xercesc::DOMElement&, const ObjectTypeDesign&);

void
operator<< (::xercesc::DOMElement&, const VariableTypeDesign&);

void
operator<< (::xercesc::DOMElement&, const DataTypeDesign&);

void
operator<< (::xercesc::DOMElement&, const ReferenceTypeDesign&);

void
operator<< (::xercesc::DOMElement&, const InstanceDesign&);

void
operator<< (::xercesc::DOMElement&, const ViewDesign&);

void
operator<< (::xercesc::DOMElement&, const ObjectDesign&);

void
operator<< (::xercesc::DOMElement&, const VariableDesign&);

void
operator<< (::xercesc::DOMElement&, const MethodDesign&);

void
operator<< (::xercesc::DOMElement&, const PropertyDesign&);

void
operator<< (::xercesc::DOMElement&, const EncodingDesign&);

void
operator<< (::xercesc::DOMElement&, const DictionaryDesign&);

void
operator<< (::xercesc::DOMElement&, const Reference&);

void
operator<< (::xercesc::DOMElement&, const ListOfReferences&);

void
operator<< (::xercesc::DOMElement&, const Parameter&);

void
operator<< (::xercesc::DOMElement&, const ListOfArguments&);

void
operator<< (::xercesc::DOMElement&, const ListOfFields&);

void
operator<< (::xercesc::DOMElement&, const ListOfEncodings&);

void
operator<< (::xercesc::DOMElement&, const ListOfChildren&);

void
operator<< (::xercesc::DOMElement&, const LocalizedText&);

void
operator<< (::xercesc::DOMElement&, const DefaultValue&);

void
operator<< (::xercesc::DOMElement&, const AccessLevel&);

void
operator<< (::xercesc::DOMAttr&, const AccessLevel&);

void
operator<< (::xml_schema::list_stream&,
            const AccessLevel&);

void
operator<< (::xercesc::DOMElement&, const ValueRank&);

void
operator<< (::xercesc::DOMAttr&, const ValueRank&);

void
operator<< (::xml_schema::list_stream&,
            const ValueRank&);

void
operator<< (::xercesc::DOMElement&, const ModellingRule&);

void
operator<< (::xercesc::DOMAttr&, const ModellingRule&);

void
operator<< (::xml_schema::list_stream&,
            const ModellingRule&);

void
operator<< (::xercesc::DOMElement&, const ModelDesign&);

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // OPC_HXX
